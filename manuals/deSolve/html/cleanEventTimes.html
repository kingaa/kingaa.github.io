<!DOCTYPE html><html><head><title>R: Find Nearest Event for Each Time Step and Clean Time Steps to...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>cleanEventTimes {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='cleanEventTimes'>
Find Nearest Event for Each Time Step and Clean Time Steps to Avoid Doubles
</h2>

<h3>Description</h3>

<p>These functions can be used for checking time steps and events used by 
ode solver functions. They are normally called internally within the solvers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestEvent(times, eventtimes)
cleanEventTimes(times, eventtimes, eps = .Machine$double.eps * 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanEventTimes_:_times">times</code></td>
<td>
<p>the vector of output times,</p>
</td></tr>
<tr><td><code id="cleanEventTimes_:_eventtimes">eventtimes</code></td>
<td>
<p>a vector with the event times,</p>
</td></tr>
<tr><td><code id="cleanEventTimes_:_eps">eps</code></td>
<td>
<p>relative tolerance value below which two numbers are assumed 
to be numerically equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In floating point arithmetics, problems can occur if values have to be
compared for 'equality' but are only close to each other and not exactly
the same.
</p>
<p>The utility functions can be used to add all <code>eventtimes</code> to
the output <code>times</code> vector, but without including times that are
very close to an event.
</p>
<p>This means that all values of <code>eventtimes</code> are contained
but only the subset of <code>times</code> that have no close neighbors in
<code>eventtimes</code>.
</p>
<p>These checks are normally performed internally by the integration solvers.
</p>


<h3>Value</h3>

<p><code>nearestEvent</code> returns a vector with the closest events for
each time step and
</p>
<p><code>cleanEventTimes</code> returns a vector with the output times
without all those that are 'very close' to an event.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt
</p>


<h3>See Also</h3>

<p><code><a href="../../deSolve/help/events.html">events</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
events &lt;- sort(c(0, 2, 3, 4 + 1e-10, 5, 7 - 1e-10,
                 7 + 6e-15, 7.5, 9, 24.9999, 25, 80, 1001, 1e300))
times  &lt;- sort(c(0, 1:7, 4.5, 6.75, 7.5, 9.2, 9.0001, 25, 879, 1e3, 1e300+5))

nearest &lt;- nearestEvent(times, events)
data.frame(times=times, nearest = nearest)

## typical usage: include all events in times after removing values that
## are numerically close together, events have priority 
times
unique_times &lt;- cleanEventTimes(times, events)
newtimes &lt;- sort(c(unique_times, events))
newtimes
</code></pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.35 <a href="00Index.html">Index</a>]</div>
</div>
</body></html>
