<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solver for Differential Algebraic Equations (DAE)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for daspk {deSolve}"><tr><td>daspk {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Solver for Differential Algebraic Equations (DAE)</h2>

<h3>Description</h3>

<p>Solves either:
</p>

<ul>
<li><p> a system of ordinary differential equations (ODE) of the form
</p>
<p style="text-align: center;"><i>y' = f(t, y, ...)</i></p>
<p> or
</p>
</li>
<li><p> a system of differential algebraic equations (DAE) of the form
</p>
<p style="text-align: center;"><i>F(t,y,y') = 0</i></p>
<p> or
</p>
</li>
<li><p> a system of linearly implicit DAES in the 
form </p>
<p style="text-align: center;"><i>M y' = f(t, y)</i></p>
    
</li></ul>

<p>using a combination of backward differentiation formula (BDF) and a
direct linear system solution method (dense or banded).
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>daspk</code> provides an interface to the FORTRAN DAE
solver of the same name, written by Linda R. Petzold, Peter N. Brown,
Alan C. Hindmarsh and Clement W. Ulrich.
</p>
<p>The system of DE's is written as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function (which may, of course,
use <code><a href="../../base/html/Foreign.html">.C</a></code>, <code>.Fortran</code>, <code><a href="../../base/html/CallExternal.html">.Call</a></code>, etc., to
call foreign code) or be defined in compiled code that has been
dynamically loaded.
</p>


<h3>Usage</h3>

<pre>
daspk(y, times, func = NULL, parms, nind = c(length(y), 0, 0), 
  dy = NULL, res = NULL, nalg = 0, 
  rtol = 1e-6, atol = 1e-6, jacfunc = NULL,
  jacres = NULL, jactype = "fullint", mass = NULL, estini = NULL,
  verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL,
  hini = 0, ynames = TRUE, maxord = 5, bandup = NULL,
  banddown = NULL, maxsteps = 5000, dllname = NULL,
  initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL,
  forcings=NULL, initforc = NULL, fcontrol=NULL,
  events = NULL, lags = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the DE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>to be used if the model is an ODE, or a DAE written in linearly
implicit form (M y' = f(t, y)). 
<code>func</code> should be an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the
values of the derivatives in the ODE system (the <em>model
definition</em>) at time t.
</p>
<p><code>func</code> must be defined as:  <code>func &lt;- function(t, y, parms,...)</code>.
<br /> <code>t</code> is the current time point in the
integration, <code>y</code> is the current estimate of the variables in
the ODE system.  If the initial values <code>y</code> has a <code>names</code>
attribute, the names will be available inside <code>func</code>, unless
<code>ynames</code> is FALSE.  <code>parms</code> is a vector or list of
parameters.  <code>...</code> (optional) are any other arguments passed to
the function.
</p>
<p>The return value of <code>func</code> should be a list,
whose first element is a vector containing the derivatives of
<code>y</code> with respect to <code>time</code>, and whose next elements are
global values that are required at each point in <code>times</code>.
The derivatives should be specified in the same order as the specification
of the state variables <code>y</code>.
</p>
<p>Note that it is not possible to define <code>func</code> as a compiled
function in a dynamically loaded shared library. Use <code>res</code>
instead.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code>,
<code>jacfunc</code>, or <code>res</code>
</p>
</td></tr>
<tr valign="top"><td><code>nind </code></td>
<td>
<p>if a DAE system: a three-valued vector with the number of
variables of index 1, 2, 3 respectively.
The equations must be defined such that the index 1 variables precede
the index 2 variables which in turn precede the index 3 variables.
The sum of the variables of different index should equal N,
the total number of variables.
Note that this has been added for consistency with <a href="../../deSolve/help/radau.html">radau</a>. 
If used, then the variables are weighed differently than in the 
original daspk code, i.e. index 2 variables are scaled with 1/h,
index 3 variables are scaled with 1/h^2. In some cases this allows
daspk to solve index 2 or index 3 problems.
</p>
</td></tr>
<tr valign="top"><td><code>dy </code></td>
<td>
<p>the initial derivatives of the state variables of the DE
system.  Ignored if an ODE.
</p>
</td></tr>
<tr valign="top"><td><code>res </code></td>
<td>
<p>if a DAE system: either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the
residual function <i>F(t,y,y')</i> of the DAE system (the model
defininition) at time <code>t</code>, or a character string giving the
name of a compiled function in a dynamically loaded shared library.
</p>
<p>If <code>res</code> is a user-supplied <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>res &lt;- function(t, y, dy, parms, ...)</code>.
</p>
<p>Here <code>t</code> is the current time point in the integration, <code>y</code>
is the current estimate of the variables in the ODE system,
<code>dy</code> are the corresponding derivatives.  If the initial
<code>y</code> or <code>dy</code> have a <code>names</code> attribute, the names will be
available inside <code>res</code>, unless <code>ynames</code> is <code>FALSE</code>.
<code>parms</code> is a vector of parameters.
</p>
<p>The return value of <code>res</code> should be a list, whose first element
is a vector containing the residuals of the DAE system,
i.e. <i>delta = F(t,y,y')</i>, and whose next elements contain output
variables that are required at each point in <code>times</code>.
</p>
<p>If <code>res</code> is a string, then <code>dllname</code> must give the name of
the shared library (without extension) which must be loaded before
<code>daspk()</code> is called (see package vignette <code>"compiledCode"</code>
for more information).
</p>
</td></tr>
<tr valign="top"><td><code>nalg </code></td>
<td>
<p>if a DAE system: the number of algebraic equations
(equations not involving derivatives). Algebraic equations should
always be the last, i.e.  preceeded by the differential equations.
</p>
<p>Only used if <code>estini</code> = 1.
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance, either a scalar or a vector,
one value for each y,
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector,
one value for each y.
</p>
</td></tr>
<tr valign="top"><td><code>jacfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes the
Jacobian of the system of differential equations. Only used in case
the system is an ODE (<i>y' = f(t, y)</i>), specified by <code>func</code>. The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
calling sequence for <code>jacfunc</code> is identical to that of
<code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <i>dydot/dy</i>, where the ith row contains the derivative of
<i>dy_i/dt</i> with respect to <i>y_j</i>, or a vector containing the
matrix elements by columns (the way <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of lsode.
</p>
</td></tr>
<tr valign="top"><td><code>jacres </code></td>
<td>
 <p><code>jacres</code> and not <code>jacfunc</code> should be used if
the system is specified by the residual function <i>F(t, y, y')</i>,
i.e. <code>jacres</code> is used in conjunction with <code>res</code>.
</p>
<p>If <code>jacres</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, the calling sequence for
<code>jacres</code> is identical to that of <code>res</code>, but with extra
parameter <code>cj</code>.  Thus it should be called as: <code>jacres = 
    func(t, y, dy, parms, cj, ...)</code>.  Here <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system, <i>y'</i> are the corresponding derivatives
and <code>cj</code> is a scalar, which is normally proportional to
the inverse of the stepsize. If the initial <code>y</code> or <code>dy</code>
have a <code>names</code> attribute, the names will be available inside
<code>jacres</code>, unless
<code>ynames</code> is <code>FALSE</code>. <code>parms</code> is a vector of
parameters (which may have a names attribute).
</p>
<p>If the Jacobian is a full matrix, <code>jacres</code> should return the
matrix <i>dG/d y + cj*dG/d y'</i>, where the <i>i</i>th row is the sum of the
derivatives of <i>G_i</i> with respect to <i>y_j</i> and the scaled
derivatives of <i>G_i</i> with respect to <i>y'_j</i>.
</p>
<p>If the Jacobian is banded, <code>jacres</code> should return only the
nonzero bands of the Jacobian, rotated rowwise. See details for the
calling sequence when <code>jacres</code> is a string.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by the user.
</p>
</td></tr>
<tr valign="top"><td><code>mass </code></td>
<td>
<p>the mass matrix. 
If not <code>NULL</code>, the problem is a linearly
implicit DAE and defined as <i>M dy/dt = f(t,y)</i>. The mass-matrix <i>M</i>
should be of dimension <i>n*n</i> where <i>n</i> is the 
number of <i>y</i>-values.
</p>
<p>If <code>mass=NULL</code> then the model is either an ODE or a DAE, specified with
<code>res</code>
</p>
</td></tr>
<tr valign="top"><td><code>estini </code></td>
<td>
<p>only if a DAE system, and if initial values of <code>y</code>
and <code>dy</code> are not consistent (i.e. <i>F(t,
     y, dy) != 0</i>), setting
<code>estini</code> = 1 or 2, will solve for them.  If <code>estini</code> = 1: dy
and the algebraic variables are estimated from <code>y</code>; in this
case, the number of algebraic equations must be given (<code>nalg</code>).
If <code>estini</code> = 2: <code>y</code> will be estimated from <code>dy</code>.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr valign="top"><td><code>tcrit </code></td>
<td>
<p>the FORTRAN routine <code>daspk</code> overshoots its targets
(times points in the vector <code>times</code>), and interpolates values
for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr valign="top"><td><code>hmin </code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>logical, if <code>FALSE</code>, names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr valign="top"><td><code>maxord </code></td>
<td>
<p>the maximum order to be allowed. Reduce <code>maxord</code>
to save storage space ( &lt;= 5)
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded (and <code>jactype</code> one of
&quot;bandint&quot;, &quot;bandusr&quot;)
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded (and <code>jactype</code> one of
&quot;bandint&quot;, &quot;bandusr&quot;)
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver; will be recalculated to be at least 500 and a multiple of
500; if <code>verbose</code> is <code>TRUE</code> 
the solver will give a warning if more than 500 steps are
taken, but it will continue till <code>maxsteps</code> steps. 
(Note this warning was always given in deSolve versions &lt; 1.10.3).
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions referred to in <code>res</code> and
<code>jacres</code>.  See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>res</code> and <code>jacres</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>res</code> and <code>jacres</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>res</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code - See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>res</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="../../deSolve/help/forcings.html">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>events </code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a
state variable is suddenly changed. See <a href="../../deSolve/help/events.html">events</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>lags </code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps
that has to be kept. To be used for delay differential equations. 
See <a href="../../deSolve/help/timelags.html">timelags</a>, <a href="../../deSolve/help/dede.html">dede</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code>,
<code>jacfunc</code>, <code>res</code> and <code>jacres</code>, allowing this to be a
generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The daspk solver uses the backward differentiation formulas of orders
one through five (specified with <code>maxord</code>) to solve either:
</p>

<ul>
<li><p> an ODE system of the form </p>
<p style="text-align: center;"><i>y' = f(t,y,...)</i></p>
  
<p>or
</p>
</li>
<li><p> a DAE system of the form </p>
<p style="text-align: center;"><i>y' = M f(t,y,...)</i></p>
 
<p>or
</p>
</li>
<li><p> a DAE system of the form </p>
<p style="text-align: center;"><i>F(t,y,y') = 0</i></p>
<p>. 
The index of the DAE should be preferable &lt;= 1.
</p>
</li></ul>

<p>ODEs are specified using argument <code>func</code>, 
DAEs are specified using argument <code>res</code>.
</p>
<p>If a DAE system, Values for y <em>and</em> y' (argument <code>dy</code>) 
at the initial time must be given as input. Ideally, these values should be consistent,
that is, if t, y, y' are the given initial values, they should
satisfy F(t,y,y') = 0.  <br /> However, if consistent values are not
known, in many cases daspk can solve for them: when <code>estini</code> = 1,
y' and algebraic variables (their number specified with <code>nalg</code>)
will be estimated, when <code>estini</code> = 2, y will be estimated.
</p>
<p>The form of the <b>Jacobian</b> can be specified by
<code>jactype</code>. This is one of:
</p>

<dl>
<dt>jactype = &quot;fullint&quot;:</dt><dd><p>a full Jacobian, calculated internally
by <code>daspk</code>, the default,
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;:</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code> or <code>jacres</code>,
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;:</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code> or <code>jacres</code>; the size of the bands
specified by <code>bandup</code> and <code>banddown</code>,
</p>
</dd>
<dt>jactype = &quot;bandint&quot;:</dt><dd><p>a banded Jacobian, calculated by
<code>daspk</code>; the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</dd>
</dl>

<p>If <code>jactype</code> = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>If jactype = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code> or <code>jacres</code>.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver.  If the request for
precision exceeds the capabilities of the machine, <code>daspk</code> will return
an error code. See <code><a href="../../deSolve/help/lsoda.html">lsoda</a></code> for details.
</p>
<p>When the index of the variables is specified (argument <code>nind</code>), 
and higher index variables
are present, then the equations are scaled such that equations corresponding
to index 2 variables are multiplied with 1/h, for index 3 they are multiplied
with 1/h^2, where h is the time step. This is not in the standard DASPK code,
but has been added for consistency with solver <a href="../../deSolve/help/radau.html">radau</a>. Because of this,
daspk can solve certain index 2 or index 3 problems.
</p>
<p><b>res and jacres</b> may be defined in compiled C or FORTRAN code, as
well as in an R-function. See package vignette <code>"compiledCode"</code>
for details.  Examples
in FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory of the
<code>deSolve</code> package directory.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="../../deSolve/help/forcings.html">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in
<code>times</code> and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the next elements of the return from <code>func</code> or
<code>res</code>, plus an additional column (the first) for the time value.
There will be one row for each element in <code>times</code> unless the
FORTRAN routine &lsquo;daspk&rsquo; returns with an unrecoverable error.  If
<code>y</code> has a names attribute, it will be used to label the columns
of the output value.
</p>


<h3>Note</h3>

<p>In this version, the Krylov method is not (yet) supported.
</p>
<p>From <code>deSolve</code> version 1.10.4 and above, the following changes were made
</p>

<ol>
<li><p> the argument list to <code>daspk</code> 
now also includes <code>nind</code>, the index of each variable. 
This is used to scale the variables, such that <code>daspk</code> in R can also solve
certain index 2 or index 3 problems, which the original Fortran version 
may not be able to solve.
</p>
</li>
<li><p> the default of <code>atol</code> was changed from 1e-8 to 1e-6,
to be consistent with the other solvers.
</p>
</li>
<li><p> the multiple warnings from daspk when the number of steps exceed 500
were toggled off unless <code>verbose</code> is <code>TRUE</code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>L. R. Petzold, A Description of DASSL: A Differential/Algebraic
System Solver, in Scientific Computing, R. S. Stepleman et al.
(Eds.), North-Holland, Amsterdam, 1983, pp. 65-68.
</p>
<p>K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical
Solution of Initial-Value Problems in Differential-Algebraic
Equations, Elsevier, New York, 1989.
</p>
<p>P. N. Brown and A. C. Hindmarsh, Reduced Storage Matrix Methods
in Stiff ODE Systems, J. Applied Mathematics and Computation,
31 (1989), pp. 40-91.
</p>
<p>P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Using Krylov
Methods in the Solution of Large-Scale Differential-Algebraic
Systems, SIAM J. Sci. Comp., 15 (1994), pp. 1467-1488.
</p>
<p>P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Consistent
Initial Condition Calculation for Differential-Algebraic
Systems, LLNL Report UCRL-JC-122175, August 1995; submitted to
SIAM J. Sci. Comp.
</p>
<p>Netlib: <a href="http://www.netlib.org">http://www.netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/radau.html">radau</a></code> for integrating DAEs up to index 3,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/rk.html">rk</a></code>, </p>
</li>
<li> <p><code><a href="../../deSolve/help/rk4.html">rk4</a></code> and <code><a href="../../deSolve/help/euler.html">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="../../deSolve/help/lsoda.html">lsoda</a></code>, <code><a href="../../deSolve/help/lsode.html">lsode</a></code>,
<code><a href="../../deSolve/help/lsodes.html">lsodes</a></code>, <code><a href="../../deSolve/help/lsodar.html">lsodar</a></code>, <code><a href="../../deSolve/help/vode.html">vode</a></code>,
for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## Coupled chemical reactions including an equilibrium
## modeled as (1) an ODE and (2) as a DAE
##
## The model describes three chemical species A,B,D:
## subjected to equilibrium reaction D &lt;- &gt; A + B
## D is produced at a constant rate, prod
## B is consumed at 1s-t order rate, r
## Chemical problem formulation 1: ODE
## =======================================================================

## Dissociation constant
K &lt;- 1 

## parameters
pars &lt;- c(
        ka   = 1e6,     # forward rate
        r    = 1,
        prod = 0.1)


Fun_ODE &lt;- function (t, y, pars)
{
  with (as.list(c(y, pars)), {
    ra  &lt;- ka*D        # forward rate
    rb  &lt;- ka/K *A*B   # backward rate

    ## rates of changes
    dD  &lt;- -ra + rb + prod
    dA  &lt;-  ra - rb
    dB  &lt;-  ra - rb - r*B
    return(list(dy = c(dA, dB, dD),
                CONC = A+B+D))
  })
}

## =======================================================================
## Chemical problem formulation 2: DAE
## 1. get rid of the fast reactions ra and rb by taking
## linear combinations   : dD+dA = prod (res1) and
##                         dB-dA = -r*B (res2)
## 2. In addition, the equilibrium condition (eq) reads:
## as ra = rb : ka*D = ka/K*A*B = &gt;      K*D = A*B
## =======================================================================

Res_DAE &lt;- function (t, y, yprime, pars)
{
  with (as.list(c(y, yprime, pars)), {

    ## residuals of lumped rates of changes
    res1 &lt;- -dD - dA + prod
    res2 &lt;- -dB + dA - r*B
    
    ## and the equilibrium equation
    eq   &lt;- K*D - A*B

    return(list(c(res1, res2, eq),
                CONC = A+B+D))
  })
}

## =======================================================================
## Chemical problem formulation 3: Mass * Func
## Based on the DAE formulation
## =======================================================================

Mass_FUN &lt;- function (t, y, pars) {
  with (as.list(c(y, pars)), {

    ## as above, but without the 
    f1 &lt;- prod
    f2 &lt;- - r*B
    
    ## and the equilibrium equation
    f3   &lt;- K*D - A*B

    return(list(c(f1, f2, f3),
                CONC = A+B+D))
  })
}
Mass &lt;- matrix(nrow = 3, ncol = 3, byrow = TRUE, 
  data=c(1,  0, 1,         # dA + 0 + dB
        -1,  1, 0,         # -dA + dB +0
         0,  0, 0))        # algebraic
         
times &lt;- seq(0, 100, by = 2)

## Initial conc; D is in equilibrium with A,B
y     &lt;- c(A = 2, B = 3, D = 2*3/K)

## ODE model solved with daspk
ODE &lt;- daspk(y = y, times = times, func = Fun_ODE,
                     parms = pars, atol = 1e-10, rtol = 1e-10)

## Initial rate of change
dy  &lt;- c(dA = 0, dB = 0, dD = 0) 

## DAE model solved with daspk
DAE &lt;- daspk(y = y, dy = dy, times = times,
         res = Res_DAE, parms = pars, atol = 1e-10, rtol = 1e-10)

MASS&lt;- daspk(y=y, times=times, func = Mass_FUN, parms = pars, mass = Mass)

## ================
## plotting output
## ================

plot(ODE, DAE, xlab = "time", ylab = "conc", type = c("l", "p"),
     pch = c(NA, 1))

legend("bottomright", lty = c(1, NA), pch = c(NA, 1),
  col = c("black", "red"), legend = c("ODE", "DAE"))

# difference between both implementations:
max(abs(ODE-DAE))

## =======================================================================
## same DAE model, now with the Jacobian
## =======================================================================
jacres_DAE &lt;- function (t, y, yprime, pars, cj)
{
    with (as.list(c(y, yprime, pars)), {
##    res1 = -dD - dA + prod
      PD[1,1] &lt;- -1*cj      # d(res1)/d(A)-cj*d(res1)/d(dA)
      PD[1,2] &lt;- 0          # d(res1)/d(B)-cj*d(res1)/d(dB)
      PD[1,3] &lt;- -1*cj      # d(res1)/d(D)-cj*d(res1)/d(dD)
##     res2 = -dB + dA - r*B
      PD[2,1] &lt;- 1*cj
      PD[2,2] &lt;- -r -1*cj
      PD[2,3] &lt;- 0
##    eq = K*D - A*B
      PD[3,1] &lt;- -B
      PD[3,2] &lt;- -A
      PD[3,3] &lt;- K
      return(PD)
   })
}

PD &lt;- matrix(ncol = 3, nrow = 3, 0)

DAE2 &lt;- daspk(y = y, dy = dy, times = times,
          res = Res_DAE, jacres = jacres_DAE, jactype = "fullusr",
          parms = pars, atol = 1e-10, rtol = 1e-10)
         
max(abs(DAE-DAE2))

## See \dynload subdirectory for a FORTRAN implementation of this model

## =======================================================================
## The chemical model as a DLL, with production a forcing function
## =======================================================================
times &lt;- seq(0, 100, by = 2)

pars &lt;- c(K = 1, ka   = 1e6, r    = 1)

## Initial conc; D is in equilibrium with A,B
y     &lt;- c(A = 2, B = 3, D = as.double(2*3/pars["K"]))

## Initial rate of change
dy  &lt;- c(dA = 0, dB = 0, dD = 0)

# production increases with time
prod &lt;- matrix(ncol = 2, 
               data = c(seq(0, 100, by = 10), 0.1*(1+runif(11)*1)))

ODE_dll &lt;- daspk(y = y, dy = dy, times = times, res = "chemres",
          dllname = "deSolve", initfunc = "initparms",
          initforc = "initforcs", parms = pars, forcings = prod,
          atol = 1e-10, rtol = 1e-10, nout = 2, 
          outnames = c("CONC","Prod"))

plot(ODE_dll, which = c("Prod", "D"), xlab = "time",
     ylab = c("/day", "conc"), main = c("production rate","D"))

</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.28 <a href="00Index.html">Index</a>]</div>
</body></html>
