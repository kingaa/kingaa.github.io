<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Implementing Events and Roots in Differential Equation...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for events {deSolve}"><tr><td>events {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Implementing Events and Roots in Differential Equation Models.
</h2>

<h3>Description</h3>

<p>An <code>event</code> occurs when the value of a state variable is suddenly
changed, e.g. because a value is added, subtracted, or multiplied. The
integration routines cannot deal easily with such state variable
changes. Typically these events occur only at specific times.  In
<code>deSolve</code>, events can be imposed by means of an input data.frame,
that specifies at which time and how a certain state variable is altered,
or via an event function.
</p>
<p>Roots occur when a root function becomes zero. By default when a root is
found, the simulation either stops (no event), or triggers an event.
</p>


<h3>Details</h3>

<p>The <code>events</code> are specified by means of argument <code>events</code>
passed to the integration routines.
</p>
<p><code>events</code> should be a list that contains one of the following:
</p>

<ol>
<li><p>func: an R-function or the name of a function in compiled
code that specifies the event,

</p>
</li>
<li><p>data: a data.frame that specifies the state variables, times, values and
types of the events. Note that the event times must also
be part of the integration output times, else the event will not take
place. As from version 1.9.1, this is checked by the solver,
and a warning message is produced if event times are missing in times;
see also <code><a href="../../deSolve/help/cleanEventTimes.html">cleanEventTimes</a></code> for utility functions
to check and solve such issues.

</p>
</li>
<li><p>time: when events are specified by an event function: the times at
which the events take place. Note that these event times must also
be part of the integration output times exactly, else the event
would not take place. As from version 1.9.1 this is checked by the solver,
and an error message produced if event times are missing in times;
see also <code><a href="../../deSolve/help/cleanEventTimes.html">cleanEventTimes</a></code> for utility functions
to check and solve such issues.

</p>
</li>
<li><p>root: when events are specified by a function and triggered
by a root, this logical should be set equal to <code>TRUE</code>

</p>
</li>
<li><p>terminalroot when events are triggered by a root, the default is
that the simulation continues after the event is executed. In
<code>terminalroot</code>, we can specify which roots should terminate the
simulation.

</p>
</li>
<li><p>maxroot: when <code>root = TRUE</code>, the maximal number of
times at with a root is found and that are kept; defaults to 100.  If
the number of roots &gt; <code>maxroot</code>, then only the first
<code>maxroot</code> will be outputted.

</p>
</li>
<li><p>ties: if events, as specified by a data.frame are &quot;ordered&quot;,
set to &quot;ordered&quot;, the default is &quot;notordered&quot;. This will save
some computational time.

</p>
</li></ol>

<p>In case the events are specified by means of an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <b>function</b>
(argument <code>events$func</code>),
it must be defined as: <code>function(t, y, parms, ...)</code>.
<code>t</code> is the current time point in the integration,
<code>y</code> is the current estimate of the variables in the ODE system.
If the initial values <code>y</code> has a <code>names</code> attribute, the
names will be available inside <code>events$func</code>.  <code>parms</code> is a
vector or list of parameters; <code>...</code> (optional) are any other
arguments passed to the function via the call to the integration method.
The event function should return the y-values (some of which modified),
as a <em>vector</em>.
</p>
<p>If <code>events$func</code> is a string, this indicates that the events are
specified by a <code>function</code> in compiled code. This function has as
arguments, the number of state variables, the time, and the state
variable vector. See package vignette &quot;compiledCode&quot; for more details.
</p>
<p>In case events are specified by an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function,
this requires either: input of the <em>time</em> of the events, a vector as
defined in <code>events$time</code>
OR the specification of a <em>root</em> function.  In the
latter case, the model must be solved with an integration routine
with root-finding capability
</p>
<p>The root function itself should be  specified with argument <code>rootfunc</code>.
In this case, the integrator is informed that the simulation it to be
continued after a root is found by
setting <code>events$root</code> equal to <code>TRUE</code>.
</p>
<p>If the events are specified by a <b>data frame</b>
(argument <code>events$data</code>), this should
contain the following columns (and in that order):
</p>

<ol>
<li><p>var the state variable <em>name</em> or <em>number</em> that is affected
by the event
</p>
</li>
<li><p>time the time at which the event is to take place; the solvers will
check if the time is embraced by the simulation time
</p>
</li>
<li><p>value the value, magnitude of the event
</p>
</li>
<li><p>method which event is to take place; should be one of (&quot;replace&quot;,
&quot;add&quot;, &quot;multiply&quot;); also allowed is to specify the number
(1 = replace, 2 = add, 3 = multiply)

</p>
</li></ol>

<p>For instance, the following line
</p>
<p><code>"v1"  10  2  "add"</code>
</p>
<p>will cause the value 2 to be added to a state variable, called <code>"v1"</code> at
<code>time = 10</code>.
</p>
<p>From deSolve version 1.9.1 the following routines have <b>root-finding</b> capability:
<a href="../../deSolve/help/lsoda.html">lsoda</a>, <a href="../../deSolve/help/lsode.html">lsode</a>, <a href="../../deSolve/help/lsodes.html">lsodes</a>, and <a href="../../deSolve/help/radau.html">radau</a>.
For the first 3 integration methods, the
root finding algorithm is based on the algorithm in solver LSODAR, and is
implemented in FORTRAN. For radau, the root solving algorithm is written
in C-code, and it works slightly different. Thus, some problems involving roots
may be more efficiently solved with either lsoda, lsode, or lsodes, while other
problems are more efficiently solved with radau.
</p>
<p>If a root function is defined, but not an event function, then by default the
solver will stop at a root. If this is not desirable, e.g. because we want
to record the position of many roots, then a dummy &quot;event&quot; function can be
defined which returns the values of the state variables - unaltered.
</p>
<p>If roots and events are combined, and roots are found, then the output will have attribute
<code>troot</code> which will contain the <code>times</code> at which a root was found (and
the event trigerred).
There will be at most <code>events$maxroot</code> such values. The default is 100.
</p>
<p>See two last examples; also see example of <code><a href="../../deSolve/help/ccl4model.html">ccl4model</a></code>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert
</p>


<h3>See Also</h3>

<p><a href="../../deSolve/help/forcings.html">forcings</a>, for how to implement forcing functions.
</p>
<p><a href="../../deSolve/help/lsodar.html">lsodar</a>, for more examples of roots
</p>


<h3>Examples</h3>

<pre>
## =============================================================================
## 1. EVENTS in a data.frame
## =============================================================================

## derivative function: derivatives set to 0
derivs &lt;- function(t, var, parms) {
  list(dvar = rep(0, 2))
}

yini &lt;- c(v1 = 1, v2 = 2)
times &lt;- seq(0, 10, by = 0.1)

eventdat &lt;- data.frame(var = c("v1", "v2", "v2", "v1"),
                       time = c(1, 1, 5, 9) ,
                       value = c(1, 2, 3, 4),
                       method = c("add", "mult", "rep", "add"))
eventdat

out &lt;- vode(func = derivs, y = yini, times = times, parms = NULL,
            events = list(data = eventdat))
plot(out)

##
eventdat &lt;- data.frame(var = c(rep("v1", 10), rep("v2", 10)),
                       time = c(1:10, 1:10),
                       value = runif(20),
                       method = rep("add", 20))
eventdat

out &lt;- ode(func = derivs, y = yini, times = times, parms = NULL,
           events = list(data = eventdat))

plot(out)

## =============================================================================
## 2. EVENTS in a function
## =============================================================================

## derivative function: rate of change v1 = 0, v2 reduced at first-order rate
derivs &lt;- function(t, var, parms) {
   list(c(0, -0.5 * var[2]))
}


# events: add 1 to v1, multiply v2 with random number
eventfun &lt;- function(t, y, parms){
  with (as.list(y),{
    v1 &lt;- v1 + 1
    v2 &lt;- 5 * runif(1)
    return(c(v1, v2))
  })
}

yini &lt;- c(v1 = 1, v2 = 2)
times &lt;- seq(0, 10, by = 0.1)

out &lt;- ode(func = derivs, y = yini, times = times, parms = NULL,
           events = list(func = eventfun, time = c(1:9, 2.2, 2.4)) )
plot(out, type = "l")

## =============================================================================
## 3. EVENTS triggered by a root function
## =============================================================================

## derivative: simple first-order decay
derivs &lt;- function(t, y, pars) {
  return(list(-0.1 * y))
}

## event triggered if state variable = 0.5
rootfun &lt;- function (t, y, pars) {
  return(y - 0.5)
}

## sets state variable = 1
eventfun &lt;- function(t, y, pars) {
  return(y = 1)
}

yini &lt;- 2
times &lt;- seq(0, 100, 0.1)

## uses ode to solve; root = TRUE specifies that the event is
## triggered by a root.
out &lt;- ode(times = times, y = yini, func = derivs, parms = NULL,
           events = list(func = eventfun, root = TRUE),
           rootfun = rootfun)

plot(out, type = "l")

## time of the root:
troot &lt;- attributes(out)$troot
points(troot, rep(0.5, length(troot)))


## =============================================================================
## 4. More ROOT examples: Rotation function
## =============================================================================
Rotate &lt;- function(t, x, p )
  list(c( x[2],
         -x[1]  ))

## Root = when second state variable = 0
rootfun &lt;- function(t, x, p) x[2]

## "event" returns state variables unchanged
eventfun &lt;- function(t, x, p) x
times &lt;- seq(from = 0, to = 15, by = 0.1)

## 1. No event: stops at first root
out1 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = rootfun)
tail(out1)

## 2. Continues till end of times and records the roots
out &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = rootfun,
           events = list(func = eventfun, root = TRUE) )

plot(out)
troot &lt;- attributes(out)$troot  # time of roots
points(troot,rep(0, length (troot)))

## Multiple roots:  either one of the state variables = 0
root2 &lt;- function(t, x, p) x

out2 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = root2,
           events = list(func = eventfun, root = TRUE) )

plot(out2, which = 2)
troot &lt;- attributes(out2)$troot
indroot &lt;- attributes(out2)$indroot  # which root was found
points(troot, rep(0, length (troot)), col = indroot, pch = 18, cex = 2)

## Multiple roots and stop at first time root 1.
out3 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
      times = times, rootfun = root2,
      events = list(func = eventfun, root = TRUE, terminalroot = 1))


## =============================================================================
## 5. Stop at 5th root - only works with radau.
## =============================================================================
Rotate &lt;- function(t, x, p )
  list(c( x[2],
         -x[1],
         0  ))

## Root = when second state variable = 0
root3  &lt;- function(t, x, p)  c(x[2], x[3] - 5)
event3 &lt;- function (t, x, p) c(x[1:2], x[3]+1)
times &lt;- seq(0, 15, 0.1)
out3 &lt;- ode(func = Rotate, y = c(x1 = 5, x2 = 5, nroot = 0),
      parms = 0, method = "radau",
      times = times, rootfun = root3,
      events = list(func = event3, root = TRUE, terminalroot = 2))
plot(out3)
attributes(out3)[c("troot", "nroot", "indroot")]

## =============================================================================
## 6 Event in R-code, model function in compiled code - based on vode example
## =============================================================================

times &lt;- 1:365
Flux &lt;- cbind(times, sin(pi*times/365)^2) # forcing function

# run without events
out &lt;- ode(y = c(C = 1), times, func = "scocder", parms = c(k=0.01),
   dllname = "deSolve", initforc = "scocforc", forcings = Flux,
   initfunc = "scocpar", nout = 2, outnames = c("Mineralisation", "Depo"))

# Event halves the concentration
EventMin &lt;- function(t, y , p) y/2

out2 &lt;- ode(y = c(C = 1), times, func = "scocder", parms = c(k=0.01),
   dllname = "deSolve", initforc = "scocforc", forcings = Flux,
   initfunc = "scocpar", nout = 2, outnames = c("Mineralisation", "Depo"),
   events = list (func = EventMin, time = c(50.1, 200, 210.5)))

plot(out, out2)


</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
