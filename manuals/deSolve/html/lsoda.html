<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solver for Ordinary Differential Equations (ODE), Switching...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for lsoda {deSolve}"><tr><td>lsoda {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Solver for Ordinary Differential Equations (ODE),
Switching Automatically Between Stiff and Non-stiff Methods
</h2>

<h3>Description</h3>

<p>Solving initial value problems for stiff or non-stiff systems of
first-order ordinary differential equations (ODEs).
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>lsoda</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Linda R. Petzold and Alan
C. Hindmarsh.
</p>
<p>The system of ODE's is written as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function (which may, of
course, use <code><a href="../../base/html/Foreign.html">.C</a></code>, <code><a href="../../base/html/Foreign.html">.Fortran</a></code>,
<code><a href="../../base/html/CallExternal.html">.Call</a></code>, etc., to call foreign code) or be defined in
compiled code that has been dynamically loaded.  A vector of
parameters is passed to the ODEs, so the solver may be used as part of
a modeling package for ODEs, or for parameter estimation using any
appropriate modeling tool for non-linear models in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> such as
<code><a href="../../stats/html/optim.html">optim</a></code>, <code><a href="../../stats/html/nls.html">nls</a></code>, <code><a href="../../stats/html/nlm.html">nlm</a></code> or
<code><a href="../../nlme/help/nlme.html">nlme</a></code>
</p>
<p><code>lsoda</code> differs from the other integrators (except <code>lsodar</code>)
in that it switches automatically between stiff and nonstiff methods.
This means that the user does not have to determine whether the
problem is stiff or not, and the solver will automatically choose the
appropriate method.  It always starts with the nonstiff method.
</p>


<h3>Usage</h3>

<pre>
lsoda(y, times, func, parms, rtol = 1e-6, atol = 1e-6,
  jacfunc = NULL, jactype = "fullint", rootfunc = NULL,
  verbose = FALSE, nroot = 0, tcrit = NULL,
  hmin = 0, hmax = NULL, hini = 0, ynames = TRUE,
  maxordn = 12, maxords = 5, bandup = NULL, banddown = NULL,
  maxsteps = 5000, dllname = NULL, initfunc = dllname,
  initpar = parms, rpar = NULL, ipar = NULL, nout = 0,
  outnames = NULL, forcings = NULL, initforc = NULL,
  fcontrol = NULL, events = NULL, lags = NULL,...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>lsoda()</code> is called. See package vignette
<code>"compiledCode"</code> for more
details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr valign="top"><td><code>jacfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, that computes the
Jacobian of the system of differential equations 
<i>dydot(i)/dy(j)</i>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <i>dydot/dy</i>, where the ith row contains the derivative of
<i>dy_i/dt</i> with respect to <i>y_j</i>, or a vector containing the
matrix elements by columns (the way <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <a href="../../deSolve/help/lsode.html">lsode</a>.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the structure of the Jacobian, one of <code>"fullint"</code>,
<code>"fullusr"</code>, <code>"bandusr"</code> or <code>"bandint"</code> - either
full or banded and estimated internally or by user.
</p>
</td></tr>
<tr valign="top"><td><code>rootfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.  When <code>rootfunc</code> is
provided, then <code>lsodar</code> will be called.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr valign="top"><td><code>nroot </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr valign="top"><td><code>tcrit </code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsoda</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>lsoda</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr valign="top"><td><code>hmin </code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>logical, if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr valign="top"><td><code>maxordn </code></td>
<td>
<p>the maximum order to be allowed in case the method is
non-stiff. Should be &lt;= 12. Reduce <code>maxord</code> to save storage space.
</p>
</td></tr>
<tr valign="top"><td><code>maxords </code></td>
<td>
<p>the maximum order to be allowed in case the method is
stiff. Should be &lt;= 5. Reduce maxord to save storage space.
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="../../deSolve/help/forcings.html">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>events </code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="../../deSolve/help/events.html">events</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>lags </code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps 
that has to be kept. To be used for delay differential equations. 
See <a href="../../deSolve/help/timelags.html">timelags</a>, <a href="../../deSolve/help/dede.html">dede</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the hard work is done by the FORTRAN subroutine <code>lsoda</code>,
whose documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/opkdmain.f</span>&rsquo;). The implementation
is based on the 12 November 2003 version of lsoda, from Netlib.
</p>
<p><code>lsoda</code> switches automatically between stiff and nonstiff
methods.  This means that the user does not have to determine whether
the problem is stiff or not, and the solver will automatically choose
the appropriate method.  It always starts with the nonstiff method.
</p>
<p>The form of the <b>Jacobian</b> can be specified by <code>jactype</code> which can
take the following values:
</p>

<dl>
<dt>&quot;fullint&quot;</dt><dd><p>a full Jacobian, calculated internally by lsoda, the default,</p>
</dd>
<dt>&quot;fullusr&quot;</dt><dd><p>a full Jacobian, specified by user function <code>jacfunc</code>,</p>
</dd>
<dt>&quot;bandusr&quot;</dt><dd><p>a banded Jacobian, specified by user function <code>jacfunc</code>
the size of the bands specified by <code>bandup</code> and <code>banddown</code>,</p>
</dd>
<dt>&quot;bandint&quot;</dt><dd><p>banded Jacobian, calculated by lsoda; the size of the bands
specified by <code>bandup</code> and <code>banddown</code>.</p>
</dd>
</dl>

<p>If <code>jactype</code> = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>The following description of <b>error control</b> is adapted from the
documentation of the lsoda source code
(input arguments <code>rtol</code> and <code>atol</code>, above):
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the error
control performed by the solver.  The solver will control the vector
<b>e</b> of estimated local errors in <b>y</b>, according to an
inequality of the form max-norm of ( <b>e</b>/<b>ewt</b> ) <i>
  &lt;= </i> 1, where <b>ewt</b> is a vector of positive error weights.  The
values of <code>rtol</code> and <code>atol</code> should all be non-negative.  The
form of <b>ewt</b> is:
</p>
<p style="text-align: center;"><i>\bold{rtol} * abs(\bold{y}) + \bold{atol}</i></p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p>If the request for precision exceeds the capabilities of the machine,
the FORTRAN subroutine lsoda will return an error code; under some
circumstances, the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>lsoda</code> will attempt a reasonable
reduction of precision in order to get an answer.  It will write a
warning if it does so.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="../../deSolve/help/forcings.html">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;lsoda&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Note</h3>

<p>The &lsquo;<span class="file">demo</span>&rsquo; directory contains some examples of using
<code><a href="../../nlme/help/gnls.html">gnls</a></code> to estimate parameters in a
dynamic model.
</p>


<h3>Author(s)</h3>

<p>R. Woodrow Setzer &lt;setzer.woodrow@epa.gov&gt;</p>


<h3>References</h3>

<p>Hindmarsh, Alan C. (1983) ODEPACK, A Systematized Collection of ODE
Solvers; in p.55&ndash;64 of Stepleman, R.W. et al.[ed.] (1983)
<em>Scientific Computing</em>, North-Holland, Amsterdam.
</p>
<p>Petzold, Linda R. (1983) Automatic Selection of Methods for Solving
Stiff and Nonstiff Systems of Ordinary Differential Equations.
<em>Siam J. Sci. Stat. Comput.</em> <b>4</b>, 136&ndash;148.
doi: <a href="https://doi.org/10.1137/0904010">10.1137/0904010</a>
</p>
<p>Netlib: <a href="https://www.netlib.org">https://www.netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/rk.html">rk</a></code>, <code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code>, <code><a href="../../deSolve/help/rk4.html">rk4</a></code> and <code><a href="../../deSolve/help/euler.html">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/lsode.html">lsode</a></code>, which can also find a root
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/lsodes.html">lsodes</a></code>, <code><a href="../../deSolve/help/lsodar.html">lsodar</a></code>, <code><a href="../../deSolve/help/vode.html">vode</a></code>,
<code><a href="../../deSolve/help/daspk.html">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## Example 1:
##   A simple resource limited Lotka-Volterra-Model
##
## Note: 
## 1. parameter and state variable names made
##    accessible via "with" function
## 2. function sigimp accessible through lexical scoping
##    (see also ode and rk examples)
## =======================================================================

SPCmod &lt;- function(t, x, parms) {
  with(as.list(c(parms, x)), {
    import &lt;- sigimp(t)
    dS &lt;- import - b*S*P + g*C     #substrate
    dP &lt;- c*S*P  - d*C*P           #producer
    dC &lt;- e*P*C  - f*C             #consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## Parameters 
parms  &lt;- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times  &lt;- seq(0, 100, length = 101)

## external signal with rectangle impulse
signal &lt;- as.data.frame(list(times = times,
                            import = rep(0,length(times))))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)


## Start values for steady state
y &lt;- xstart &lt;- c(S = 1, P = 1, C = 1)

## Solving
out &lt;-  lsoda(xstart, times, SPCmod, parms) 

## Plotting
mf &lt;- par("mfrow")
plot(out, main = c("substrate", "producer", "consumer"))
plot(out[,"P"], out[,"C"], type = "l", xlab = "producer", ylab = "consumer")
par(mfrow = mf)

## =======================================================================
## Example 2:
##  from lsoda source code
## =======================================================================

## names makes this easier to read, but may slow down execution.
parms   &lt;- c(k1 = 0.04, k2 = 1e4, k3 = 3e7)
my.atol &lt;- c(1e-6,  1e-10,  1e-6)
times   &lt;- c(0,4 * 10^(-1:10))

lsexamp &lt;- function(t, y, p) {
  yd1 &lt;- -p["k1"] * y[1] + p["k2"] * y[2]*y[3]
  yd3 &lt;- p["k3"] * y[2]^2
  list(c(yd1, -yd1-yd3, yd3), c(massbalance = sum(y)))
}

exampjac &lt;- function(t, y, p) {
  matrix(c(-p["k1"],	   p["k1"],       0,

            p["k2"]*y[3],
          - p["k2"]*y[3] - 2*p["k3"]*y[2],
                           2*p["k3"]*y[2],

          p["k2"]*y[2],  -p["k2"]*y[2],  0
          ), 3, 3)
}
  

## measure speed (here and below)
system.time( 
  out &lt;- lsoda(c(1, 0, 0), times, lsexamp, parms, rtol = 1e-4,
           atol = my.atol, hmax = Inf)
)  
out

## This is what the authors of lsoda got for the example:

## the output of this program (on a cdc-7600 in single precision)
## is as follows..
##
## at t =  4.0000e-01   y =  9.851712e-01  3.386380e-05  1.479493e-02
## at t =  4.0000e+00   y =  9.055333e-01  2.240655e-05  9.444430e-02
## at t =  4.0000e+01   y =  7.158403e-01  9.186334e-06  2.841505e-01
## at t =  4.0000e+02   y =  4.505250e-01  3.222964e-06  5.494717e-01
## at t =  4.0000e+03   y =  1.831975e-01  8.941774e-07  8.168016e-01
## at t =  4.0000e+04   y =  3.898730e-02  1.621940e-07  9.610125e-01
## at t =  4.0000e+05   y =  4.936363e-03  1.984221e-08  9.950636e-01
## at t =  4.0000e+06   y =  5.161831e-04  2.065786e-09  9.994838e-01
## at t =  4.0000e+07   y =  5.179817e-05  2.072032e-10  9.999482e-01
## at t =  4.0000e+08   y =  5.283401e-06  2.113371e-11  9.999947e-01
## at t =  4.0000e+09   y =  4.659031e-07  1.863613e-12  9.999995e-01
## at t =  4.0000e+10   y =  1.404280e-08  5.617126e-14  1.000000e+00

## Using the analytic Jacobian speeds up execution a little :

system.time( 
  outJ &lt;- lsoda(c(1, 0, 0), times, lsexamp, parms, rtol = 1e-4,
            atol = my.atol, jacfunc = exampjac, jactype = "fullusr", hmax = Inf)
)
  
all.equal(as.data.frame(out), as.data.frame(outJ)) # TRUE
diagnostics(out)
diagnostics(outJ) # shows what lsoda did internally

</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
