<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solver For Multicomponent 1-D Ordinary Differential Equations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for ode.1D {deSolve}"><tr><td>ode.1D {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Solver For Multicomponent 1-D Ordinary Differential Equations</h2>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations
resulting from 1-Dimensional partial differential equations
that have been converted to ODEs by numerical differencing.
</p>


<h3>Usage</h3>

<pre>ode.1D(y, times, func, parms, nspec = NULL, dimens = NULL, 
   method= c("lsoda", "lsode", "lsodes", "lsodar", "vode", "daspk",
   "euler", "rk4", "ode23", "ode45", "radau", "bdf", "adams", "impAdams",
   "iteration"),
   names = NULL, bandwidth = 1, restructure = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a character string then integrator <code>lsodes</code>
will be used. See details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr valign="top"><td><code>nspec </code></td>
<td>
<p>the number of <b>species</b> (components) in the model. If
<code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr valign="top"><td><code>dimens</code></td>
<td>
<p>the number of <b>boxes</b> in the model. If <code>NULL</code>, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the integrator. Use <code>"vode", "lsode", "lsoda", 
     "lsodar", "daspk"</code>, or <code>"lsodes"</code> if the model is very stiff;
<code>"impAdams"</code> or <code>"radau"</code> may be best suited for mildly stiff problems; 
<code>"euler", "rk4", "ode23", "ode45", "adams"</code> are most
efficient for non-stiff problems. Also allowed is to pass an integrator
<code>function</code>. Use one of the other Runge-Kutta methods via 
<code>rkMethod</code>. For instance, <code>method = rkMethod("ode45ck")</code> will
trigger the Cash-Karp method of order 4(5).
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>)
</p>
</td></tr>
<tr valign="top"><td><code>names </code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr valign="top"><td><code>bandwidth </code></td>
<td>
<p>the number of adjacent boxes over which transport occurs.
Normally equal to 1 (box i only interacts with box i-1, and i+1). 
Values larger than 1 will not work with <code>method = "lsodes"</code>.
Ignored if the method is explicit.
</p>
</td></tr>
<tr valign="top"><td><code>restructure </code></td>
<td>
<p>whether or not the Jacobian should be restructured.
Only used if the <code>method</code> is an integrator function. Should be
<code>TRUE</code> if the method is implicit, <code>FALSE</code> if explicit.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to the integrator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for multi-species 1-dimensional models,
that are only subjected to transport between adjacent layers.
</p>
<p>More specifically, this method is to be used if the state variables
are arranged per species:
</p>
<p>A[1], A[2], A[3],.... B[1], B[2], B[3],.... (for species A, B))
</p>
<p>Two methods are implemented.
</p>

<ul>
<li><p> The default method rearranges the state variables as
A[1], B[1], ... A[2], B[2], ... A[3], B[3], .... This reformulation leads
to a banded Jacobian with (upper and lower) half bandwidth =
number of species.
</p>
<p>Then the selected integrator solves the banded problem.
</p>
</li>
<li><p> The second method uses <code>lsodes</code>. Based on the dimension
of the problem, the method first calculates the sparsity pattern
of the Jacobian, under the assumption that transport is only
occurring between adjacent layers. Then <code>lsodes</code> is called to
solve the problem.
</p>
<p>As <code>lsodes</code> is used to integrate, it may be necessary to
specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is possible
that this will be too low.  In this case, <code>ode.1D</code> will
return with an error message telling the size of the work array
actually needed. In the second try then, set <code>lrw</code> equal to
this number.
</p>
<p>For instance, if you get the error:
</p>
<pre>   
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>      
<p>set <code>lrw</code> equal to 27627 or a higher value
</p>
</li></ul>

<p>If the model is specified in compiled code (in a DLL), then option 2,
based on <code>lsodes</code> is the only solution method.
</p>
<p>For single-species 1-D models, you may also use <code><a href="../../deSolve/help/ode.band.html">ode.band</a></code>.
</p>
<p>See the selected integrator for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in times and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements.  The first element of istate
returns the conditions under which the last call to the integrator
returned. Normal is <code>istate = 2</code>.  If <code>verbose = TRUE</code>, the
settings of istate and rstate will be written to the screen. See the
help for the selected integrator for details.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify <b>both</b>
<code>nspec</code> and <code>dimens</code>. In this case, the solver can check
whether the input makes sense (i.e. if <code>nspec * dimens ==
  length(y)</code>).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for integrating models with a banded Jacobian
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/lsodes.html">lsodes</a></code>,<code><a href="../../deSolve/help/lsode.html">lsode</a></code>, <code><a href="../../deSolve/help/lsoda.html">lsoda</a></code>,
<code><a href="../../deSolve/help/lsodar.html">lsodar</a></code>,<code><a href="../../deSolve/help/vode.html">vode</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre>

## =======================================================================
## example 1
## a predator and its prey diffusing on a flat surface
## in concentric circles
## 1-D model with using cylindrical coordinates
## Lotka-Volterra type biology
## =======================================================================

## ================
## Model equations
## ================

lvmod &lt;- function (time, state, parms, N, rr, ri, dr, dri) {
  with (as.list(parms), {
    PREY &lt;- state[1:N]
    PRED &lt;- state[(N+1):(2*N)]

    ## Fluxes due to diffusion
    ## at internal and external boundaries: zero gradient
    FluxPrey &lt;- -Da * diff(c(PREY[1], PREY, PREY[N]))/dri
    FluxPred &lt;- -Da * diff(c(PRED[1], PRED, PRED[N]))/dri

    ## Biology: Lotka-Volterra model
    Ingestion     &lt;- rIng  * PREY * PRED
    GrowthPrey    &lt;- rGrow * PREY * (1-PREY/cap)
    MortPredator  &lt;- rMort * PRED

    ## Rate of change = Flux gradient + Biology
    dPREY    &lt;- -diff(ri * FluxPrey)/rr/dr   +
                GrowthPrey - Ingestion
    dPRED    &lt;- -diff(ri * FluxPred)/rr/dr   +
                Ingestion * assEff - MortPredator

    return (list(c(dPREY, dPRED)))
  })
}

## ==================
## Model application
## ==================

## model parameters:

R  &lt;- 20                        # total radius of surface, m
N  &lt;- 100                       # 100 concentric circles
dr &lt;- R/N                       # thickness of each layer
r  &lt;- seq(dr/2,by = dr,len = N) # distance of center to mid-layer
ri &lt;- seq(0,by = dr,len = N+1)  # distance to layer interface
dri &lt;- dr                       # dispersion distances

parms &lt;- c(Da     = 0.05,       # m2/d, dispersion coefficient
           rIng   = 0.2,        # /day, rate of ingestion
           rGrow  = 1.0,        # /day, growth rate of prey
           rMort  = 0.2 ,       # /day, mortality rate of pred
           assEff = 0.5,        # -, assimilation efficiency
           cap    = 10)         # density, carrying capacity

## Initial conditions: both present in central circle (box 1) only
state    &lt;- rep(0, 2 * N)
state[1] &lt;- state[N + 1] &lt;- 10
                
## RUNNING the model:
times  &lt;- seq(0, 200, by = 1)   # output wanted at these time intervals

## the model is solved by the two implemented methods:
## 1. Default: banded reformulation
print(system.time(
  out &lt;- ode.1D(y = state, times = times, func = lvmod, parms = parms,
                nspec = 2, names = c("PREY", "PRED"),
                N = N, rr = r, ri = ri, dr = dr, dri = dri)
))

## 2. Using sparse method
print(system.time(
  out2 &lt;- ode.1D(y = state, times = times, func = lvmod, parms = parms,
                 nspec = 2, names = c("PREY","PRED"), 
                 N = N, rr = r, ri = ri, dr = dr, dri = dri,
                 method = "lsodes")
))

## ================
## Plotting output
## ================
# the data in 'out' consist of: 1st col times, 2-N+1: the prey
# N+2:2*N+1: predators

PREY   &lt;- out[, 2:(N + 1)]

filled.contour(x = times, y = r, PREY, color = topo.colors,
               xlab = "time, days", ylab = "Distance, m",
               main = "Prey density")
# similar:
image(out, which = "PREY", grid = r, xlab = "time, days", 
      legend = TRUE, ylab = "Distance, m", main = "Prey density")

image(out2, grid = r)

# summaries of 1-D variables
summary(out)

# 1-D plots:
matplot.1D(out, type = "l", subset = time == 10)
matplot.1D(out, type = "l", subset = time &gt; 10 &amp; time &lt; 20)

## =======================================================================
## Example 2.
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river
## =======================================================================

## ================
## Model equations
## ================
O2BOD &lt;- function(t, state, pars) {
  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

  ## BOD dynamics
  FluxBOD &lt;- v * c(BOD_0, BOD)   # fluxes due to water transport
  FluxO2  &lt;- v * c(O2_0, O2)
  
  BODrate &lt;- r * BOD             # 1-st order consumption

  ## rate of change = flux gradient  - consumption + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx - BODrate
  dO2          &lt;- -diff(FluxO2)/dx  - BODrate      +  p * (O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2)))
}
 
 
## ==================
## Model application
## ==================
## parameters
dx      &lt;- 25        # grid size of 25 meters
v       &lt;- 1e3       # velocity, m/day
x       &lt;- seq(dx/2, 5000, by = dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.05      # /day, first-order decay of BOD
p       &lt;- 0.5       # /day, air-sea exchange rate 
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 200       # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1000      # mmol/m3 riverine BOD concentration

## initial conditions:
state &lt;- c(rep(200, N), rep(200, N))
times &lt;- seq(0, 20, by = 0.1)

## running the model
##  step 1  : model spinup
out &lt;- ode.1D(y = state, times, O2BOD, parms = NULL, 
              nspec = 2, names = c("BOD", "O2"))

## ================
## Plotting output
## ================
## select oxygen (first column of out:time, then BOD, then O2
O2   &lt;- out[, (N + 2):(2 * N + 1)]
color = topo.colors

filled.contour(x = times, y = x, O2, color = color, nlevels = 50,
               xlab = "time, days", ylab = "Distance from river, m",
               main = "Oxygen")
               
## or quicker plotting:
image(out, grid = x,  xlab = "time, days", ylab = "Distance from river, m")               
</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
