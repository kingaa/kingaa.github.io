<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solver for 2-Dimensional Ordinary Differential Equations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ode.2D {deSolve}"><tr><td>ode.2D {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Solver for 2-Dimensional Ordinary Differential Equations</h2>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations resulting from
2-Dimensional partial differential equations
that have been converted to ODEs by numerical differencing.
</p>


<h3>Usage</h3>

<pre>
ode.2D(y, times, func, parms, nspec = NULL, dimens,
  method= c("lsodes", "euler", "rk4", "ode23", "ode45", "adams", "iteration"),
  names = NULL, cyclicBnd = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>. <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr valign="top"><td><code>nspec </code></td>
<td>
<p>the number of <b>species</b> (components) in the model.</p>
</td></tr>
<tr valign="top"><td><code>dimens</code></td>
<td>
<p>2-valued vector with the number of <b>boxes</b> in two
dimensions in the model. 
</p>
</td></tr>
<tr valign="top"><td><code>cyclicBnd </code></td>
<td>
<p>if not <code>NULL</code> then a number or a 2-valued vector
with the dimensions where a cyclic boundary is used - <code>1</code>: x-dimension,
<code>2</code>: y-dimension; see details.
</p>
</td></tr>
<tr valign="top"><td><code>names </code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the integrator. Use <code>"lsodes"</code> if the model is very stiff;
<code>"impAdams"</code> may be best suited for mildly stiff problems; 
<code>"euler", "rk4", "ode23", "ode45", "adams"</code> are most
efficient for non-stiff problems. Also allowed is to pass an integrator
<code>function</code>. Use one of the other Runge-Kutta methods via 
<code>rkMethod</code>. For instance, <code>method = rkMethod("ode45ck")</code> will
trigger the Cash-Karp method of order 4(5).
</p>
<p>If  <code>"lsodes"</code> is used, then also the size of the work array should
be specified (<code>lrw</code>) (see <a href="../../deSolve/help/lsodes.html">lsodes</a>).
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>)
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>lsodes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for 2-dimensional models, that are only
subjected to transport between adjacent layers.
</p>
<p>Based on the dimension of the problem, and if <code>lsodes</code> is used as 
the integrator, the method first calculates the
sparsity pattern of the Jacobian, under the assumption that transport
is only occurring between adjacent layers. Then <code>lsodes</code> is
called to solve the problem.
</p>
<p>If the model is not stiff, then it is more efficient to use one of the 
explicit integration routines
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
boxes in x-or y-direction interact with the last boxes. In this case, there
will be extra non-zero fringes in the Jacobian which need to be taken
into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd</code>. For innstance,
<code>cyclicBnd = 1</code> indicates that a cyclic boundary is required only for
the x-direction, whereas <code>cyclicBnd = c(1,2)</code> imposes a cyclic boundary
for both x- and y-direction. The default is no cyclic boundaries.
</p>
<p>If <code>lsodes</code> is used to integrate, it will probably be necessary
to specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is likely that
this will be too low.  In this case, <code>ode.2D</code> will return with an
error message telling the size of the work array actually needed. In
the second try then, set <code>lrw</code> equal to this number.
</p>
<p>For instance, if you get the error:
</p>
<pre>   
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>      
<p>set <code>lrw</code> equal to 27627 or a higher value.
</p>
<p>See <a href="../../deSolve/help/lsodes.html">lsodes</a> for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in times and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements.  The first element of istate
returns the conditions under which the last call to the integrator
returned. Normal is <code>istate = 2</code>.  If <code>verbose = TRUE</code>, the
settings of istate and rstate will be written to the screen. See the
help for the selected integrator for details.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify <b>both</b>
<code>nspec</code> and <code>dimens</code>. In this case, the solver can check
whether the input makes sense (as <code>nspec * dimens[1] * dimens[2]
  == length(y)</code>).
</p>
<p>Do <b>not</b> use this method for problems that are not 2D!
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for integrating models with a banded Jacobian
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/lsodes.html">lsodes</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## A Lotka-Volterra predator-prey model with predator and prey
## dispersing in 2 dimensions
## =======================================================================

## ==================
## Model definitions
## ==================

lvmod2D &lt;- function (time, state, pars, N, Da, dx) {
  NN &lt;- N*N
  Prey &lt;- matrix(nrow = N, ncol = N,state[1:NN])
  Pred &lt;- matrix(nrow = N, ncol = N,state[(NN+1):(2*NN)])

  with (as.list(pars), {
    ## Biology
    dPrey &lt;- rGrow * Prey * (1- Prey/K) - rIng  * Prey * Pred
    dPred &lt;- rIng  * Prey * Pred*assEff - rMort * Pred

    zero &lt;- rep(0, N)

    ## 1. Fluxes in x-direction; zero fluxes near boundaries
    FluxPrey &lt;- -Da * rbind(zero,(Prey[2:N,] - Prey[1:(N-1),]), zero)/dx
    FluxPred &lt;- -Da * rbind(zero,(Pred[2:N,] - Pred[1:(N-1),]), zero)/dx

    ## Add flux gradient to rate of change
    dPrey    &lt;- dPrey - (FluxPrey[2:(N+1),] - FluxPrey[1:N,])/dx
    dPred    &lt;- dPred - (FluxPred[2:(N+1),] - FluxPred[1:N,])/dx

    ## 2. Fluxes in y-direction; zero fluxes near boundaries
    FluxPrey &lt;- -Da * cbind(zero,(Prey[,2:N] - Prey[,1:(N-1)]), zero)/dx
    FluxPred &lt;- -Da * cbind(zero,(Pred[,2:N] - Pred[,1:(N-1)]), zero)/dx

    ## Add flux gradient to rate of change
    dPrey    &lt;- dPrey - (FluxPrey[,2:(N+1)] - FluxPrey[,1:N])/dx
    dPred    &lt;- dPred - (FluxPred[,2:(N+1)] - FluxPred[,1:N])/dx

    return(list(c(as.vector(dPrey), as.vector(dPred))))
 })
}


## ===================
## Model applications
## ===================

pars    &lt;- c(rIng   = 0.2,    # /day, rate of ingestion
             rGrow  = 1.0,    # /day, growth rate of prey
             rMort  = 0.2 ,   # /day, mortality rate of predator
             assEff = 0.5,    # -, assimilation efficiency
             K      = 5  )    # mmol/m3, carrying capacity

R  &lt;- 20                      # total length of surface, m
N  &lt;- 50                      # number of boxes in one direction
dx &lt;- R/N                     # thickness of each layer
Da &lt;- 0.05                    # m2/d, dispersion coefficient

NN &lt;- N*N                     # total number of boxes

## initial conditions
yini    &lt;- rep(0, 2*N*N)
cc      &lt;- c((NN/2):(NN/2+1)+N/2, (NN/2):(NN/2+1)-N/2)
yini[cc] &lt;- yini[NN+cc] &lt;- 1

## solve model (5000 state variables...  use Cash-Karp Runge-Kutta method
times   &lt;- seq(0, 50, by = 1)
out &lt;- ode.2D(y = yini, times = times, func = lvmod2D, parms = pars,
              dimens = c(N, N), names = c("Prey", "Pred"),
              N = N, dx = dx, Da = Da, method = rkMethod("rk45ck"))

diagnostics(out)
summary(out)

# Mean of prey concentration at each time step
Prey &lt;- subset(out, select = "Prey", arr = TRUE)
dim(Prey)
MeanPrey &lt;- apply(Prey, MARGIN = 3, FUN = mean)
plot(times, MeanPrey)

## Not run: 
## plot results
Col &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                          "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

for (i in seq(1, length(times), by = 1))
   image(Prey[ , ,i],
   col = Col(100), xlab = , zlim = range(out[,2:(NN+1)]))

## similar, plotting both and adding a margin text with times:
image(out, xlab = "x", ylab = "y", mtext = paste("time = ", times))

## End(Not run)

select &lt;- c(1, 40)
image(out, xlab = "x", ylab = "y", mtext = "Lotka-Volterra in 2-D",
      subset = select, mfrow = c(2,2), legend =  TRUE)


# plot prey and pred at t = 10; first use subset to select data
prey10 &lt;-  matrix (nrow = N, ncol = N, 
     data = subset(out, select = "Prey", subset = (time == 10)))
pred10 &lt;-  matrix (nrow = N, ncol = N, 
     data = subset(out, select = "Pred", subset = (time == 10)))

mf &lt;- par(mfrow = c(1, 2))
image(prey10)
image(pred10)
par (mfrow = mf)

# same, using deSolve's image:
image(out, subset = (time == 10))

## =======================================================================
## An example with a cyclic boundary condition.
## Diffusion in 2-D; extra flux on 2 boundaries,
## cyclic boundary in y
## =======================================================================


diffusion2D &lt;- function(t, Y, par) {
  y    &lt;- matrix(nrow = nx, ncol = ny, data = Y)  # vector to 2-D matrix
  dY   &lt;- -r * y       # consumption
  BNDx &lt;- rep(1, nx)   # boundary concentration
  BNDy &lt;- rep(1, ny)   # boundary concentration

  ## diffusion in X-direction; boundaries=imposed concentration
  Flux &lt;- -Dx * rbind(y[1,] - BNDy, (y[2:nx,] - y[1:(nx-1),]), BNDy - y[nx,])/dx
  dY   &lt;- dY - (Flux[2:(nx+1),] - Flux[1:nx,])/dx

  ## diffusion in Y-direction
  Flux &lt;- -Dy * cbind(y[,1] - BNDx, (y[,2:ny]-y[,1:(ny-1)]), BNDx - y[,ny])/dy
  dY   &lt;- dY - (Flux[,2:(ny+1)] - Flux[,1:ny])/dy

  ## extra flux on two sides
  dY[,1] &lt;- dY[,1] + 10
  dY[1,] &lt;- dY[1,] + 10

  ## and exchange between sides on y-direction
  dY[,ny] &lt;- dY[,ny] + (y[,1] - y[,ny]) * 10
  return(list(as.vector(dY)))
}

## parameters
dy &lt;- dx &lt;- 1  # grid size
Dy &lt;- Dx &lt;- 1  # diffusion coeff, X- and Y-direction
r  &lt;- 0.05     # consumption rate

nx &lt;- 50
ny &lt;- 100
y  &lt;- matrix(nrow = nx, ncol = ny, 1)

## model most efficiently solved with lsodes - need to specify lrw

print(system.time(
  ST3 &lt;- ode.2D(y, times = 1:100, func = diffusion2D, parms = NULL,
                dimens = c(nx, ny), verbose = TRUE, names = "Y",
                lrw = 400000, atol = 1e-10, rtol = 1e-10, cyclicBnd = 2)
))

# summary of 2-D variable
summary(ST3)

# plot output at t = 10
t10 &lt;-  matrix (nrow = nx, ncol = ny, 
     data = subset(ST3, select = "Y", subset = (time == 10)))

persp(t10, theta = 30, border = NA, phi = 70, 
     col = "lightblue", shade = 0.5, box = FALSE)

# image plot, using deSolve's image function
image(ST3, subset = time == 10, method = "persp",
      theta = 30, border = NA, phi = 70, main = "", 
      col = "lightblue", shade = 0.5, box = FALSE)

## Not run: 
zlim &lt;- range(ST3[, -1])
for (i in 2:nrow(ST3)) {
  y &lt;- matrix(nrow = nx, ncol = ny, data = ST3[i, -1])
  filled.contour(y, zlim = zlim, main = i)
}

# same
image(ST3, method = "filled.contour")

## End(Not run)

</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.28 <a href="00Index.html">Index</a>]</div>
</body></html>
