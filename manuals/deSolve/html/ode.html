<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: General Solver for Ordinary Differential Equations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for ode {deSolve}"><tr><td>ode {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>General Solver for Ordinary Differential Equations</h2>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations; a wrapper
around the implemented ODE solvers</p>


<h3>Usage</h3>

<pre>ode(y, times, func, parms, 
method = c("lsoda", "lsode", "lsodes", "lsodar", "vode", "daspk",
           "euler", "rk4", "ode23", "ode45", "radau", 
           "bdf", "bdf_d", "adams", "impAdams", "impAdams_d", "iteration"), ...)

## S3 method for class 'deSolve'
print(x, ...)
## S3 method for class 'deSolve'
summary(object, select = NULL, which = select, 
                 subset = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time t, or a
character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>ode</code> is called. See package vignette
<code>"compiledCode"</code> for more details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the integrator to use, either a <b>function</b> that performs 
integration, or a <b>list</b> of class <code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code>, or a <b>string</b> 
(<code>"lsoda"</code>,
<code>"lsode"</code>, <code>"lsodes"</code>,<code>"lsodar"</code>,<code>"vode"</code>,
<code>"daspk"</code>, <code>"euler"</code>, <code>"rk4"</code>,   <code>"ode23"</code>,
<code>"ode45"</code>, <code>"radau"</code>, <code>"bdf"</code>,   <code>"bdf_d"</code>, <code>"adams"</code>, 
<code>"impAdams"</code> or <code>"impAdams_d"</code>  ,&quot;iteration&quot;).
Options &quot;bdf&quot;, &quot;bdf_d&quot;, &quot;adams&quot;, &quot;impAdams&quot; or &quot;impAdams_d&quot; are the backward
differentiation formula, the BDF with diagonal representation of the Jacobian,
the (explicit) Adams and the implicit Adams method, and the implicit Adams
method with diagonal representation of the Jacobian respectively (see details).
The default integrator used is <a href="../../deSolve/help/lsoda.html">lsoda</a>.
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>).
See last example.
</p>
</td></tr>
<tr valign="top"><td><code>x </code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and to be printed or to be subsetted.
</p>
</td></tr>
<tr valign="top"><td><code>object </code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and whose summary is to be calculated. In contrast to R's default,
this returns a data.frame. It returns one summary column for a multi-dimensional variable.
</p>
</td></tr>
<tr valign="top"><td><code>which </code></td>
<td>
<p>the name(s) or the index to the variables whose summary should be
estimated.  Default = all variables. </p>
</td></tr>
<tr valign="top"><td><code>select </code></td>
<td>
<p>which variable/columns to be selected.
</p>
</td></tr>
<tr valign="top"><td><code>subset </code></td>
<td>
<p>logical expression indicating elements or rows to keep when 
calculating a <code>summary</code>: missing values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to the integrator or to the
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a wrapper around the various ode solvers.
</p>
<p>See package vignette for information about specifying the model in
compiled code.
</p>
<p>See the selected integrator for the additional options.
</p>
<p>The default integrator used is <code><a href="../../deSolve/help/lsoda.html">lsoda</a></code>.
</p>
<p>The option <code>method = "bdf"</code> provdes a handle to the backward 
differentiation formula (it is equal to using <code>method = "lsode"</code>). 
It is best suited to solve stiff (systems of) equations.
</p>
<p>The option <code>method = "bdf_d"</code> selects the backward 
differentiation formula that uses Jacobi-Newton iteration (neglecting the 
off-diagonal elements of the Jacobian (it is equal to using 
<code>method = "lsode", mf = 23</code>). 
It is best suited to solve stiff (systems of) equations.
</p>
<p><code>method = "adams"</code> triggers the Adams method that uses functional
iteration (no Jacobian used); 
(equal to <code>method = "lsode", mf = 10</code>. It is often the best 
choice for solving non-stiff (systems of) equations. Note: when functional
iteration is used, the method is often said to be explicit, although it is  
in fact implicit.
</p>
<p><code>method = "impAdams"</code> selects the implicit Adams method that uses Newton-
Raphson iteration (equal to <code>method = "lsode", mf = 12</code>.
</p>
<p><code>method = "impAdams_d"</code> selects the implicit Adams method that uses Jacobi-
Newton iteration, i.e. neglecting all off-diagonal elements (equal to 
<code>method = "lsode", mf = 13</code>.
</p>
<p>For very stiff systems, <code>method = "daspk"</code> may outperform 
<code>method = "bdf"</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in
<code>times</code> and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/plot.deSolve.html">plot.deSolve</a></code> for plotting the outputs,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/dede.html">dede</a></code> general solver for delay differential equations
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/aquaphy.html">aquaphy</a></code>, <code><a href="../../deSolve/help/ccl4model.html">ccl4model</a></code>, where
<code>ode</code> is used,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/lsoda.html">lsoda</a></code>, <code><a href="../../deSolve/help/lsode.html">lsode</a></code>,
<code><a href="../../deSolve/help/lsodes.html">lsodes</a></code>, <code><a href="../../deSolve/help/lsodar.html">lsodar</a></code>, <code><a href="../../deSolve/help/vode.html">vode</a></code>,
<code><a href="../../deSolve/help/daspk.html">daspk</a></code>, <code><a href="../../deSolve/help/radau.html">radau</a></code>,
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/rk.html">rk</a></code>, <code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code> for additional
Runge-Kutta methods,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/forcings.html">forcings</a></code> and <code><a href="../../deSolve/help/events.html">events</a></code>,
</p>
</li>
<li>  <p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.  
</p>
</li></ul>



<h3>Examples</h3>

<pre>

## =======================================================================
## Example1: Predator-Prey Lotka-Volterra model (with logistic prey)
## =======================================================================

LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator

    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator

    return(list(c(dPrey, dPredator)))
  })
}

pars  &lt;- c(rIng   = 0.2,    # /day, rate of ingestion
           rGrow  = 1.0,    # /day, growth rate of prey
           rMort  = 0.2 ,   # /day, mortality rate of predator
           assEff = 0.5,    # -, assimilation efficiency
           K      = 10)     # mmol/m3, carrying capacity

yini  &lt;- c(Prey = 1, Predator = 2)
times &lt;- seq(0, 200, by = 1)
out   &lt;- ode(yini, times, LVmod, pars)
summary(out)

## Default plot method
plot(out)

## User specified plotting
matplot(out[ , 1], out[ , 2:3], type = "l", xlab = "time", ylab = "Conc",
        main = "Lotka-Volterra", lwd = 2)
legend("topright", c("prey", "predator"), col = 1:2, lty = 1:2)

## =======================================================================
## Example2: Substrate-Producer-Consumer Lotka-Volterra model
## =======================================================================

## Note:
## Function sigimp passed as an argument (input) to model
##   (see also lsoda and rk examples)

SPCmod &lt;- function(t, x, parms, input)  {
  with(as.list(c(parms, x)), {
    import &lt;- input(t)
    dS &lt;- import - b*S*P + g*C    # substrate
    dP &lt;- c*S*P  - d*C*P          # producer
    dC &lt;- e*P*C  - f*C            # consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## The parameters 
parms &lt;- c(b = 0.001, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times &lt;- seq(0, 200, length = 101)

## external signal with rectangle impulse
signal &lt;- data.frame(times = times,
                     import = rep(0, length(times)))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)

## Start values for steady state
xstart &lt;- c(S = 1, P = 1, C = 1)

## Solve model
out &lt;- ode(y = xstart, times = times,
           func = SPCmod, parms = parms, input = sigimp)

## Default plot method
plot(out)

## User specified plotting
mf &lt;- par(mfrow = c(1, 2))
matplot(out[,1], out[,2:4], type = "l", xlab = "time", ylab = "state")
legend("topright", col = 1:3, lty = 1:3, legend = c("S", "P", "C"))
plot(out[,"P"], out[,"C"], type = "l", lwd = 2, xlab = "producer",
  ylab = "consumer")
par(mfrow = mf)

## =======================================================================
## Example3: Discrete time model - using method = "iteration"
##           The host-parasitoid model from Soetaert and Herman, 2009, 
##           Springer - p. 284.
## =======================================================================

Parasite &lt;- function(t, y, ks) {
  P &lt;- y[1]
  H &lt;- y[2]
  f    &lt;- A * P / (ks + H)
  Pnew &lt;- H * (1 - exp(-f))
  Hnew &lt;- H * exp(rH * (1 - H) - f)
  
  list (c(Pnew, Hnew))
}
rH &lt;- 2.82 # rate of increase
A  &lt;- 100  # attack rate
ks &lt;- 15   # half-saturation density

out &lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = ks,
           method = "iteration")
            
out2&lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = 25,
           method = "iteration")

out3&lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = 35,
           method = "iteration")

## Plot all 3 scenarios in one figure
plot(out, out2, out3, lty = 1, lwd = 2)

## Same like "out", but *output* every two steps
## hini = 1 ensures that the same *internal* timestep of 1 is used
outb &lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5),
            times = seq(0, 50, 2), hini = 1, parms = ks,
            method = "iteration")
plot(out, outb, type = c("l", "p"))

## Not run: 
## =======================================================================
## Example4: Playing with the Jacobian options - see e.g. lsoda help page
##
## IMPORTANT: The following example is temporarily broken because of 
##            incompatibility with R 3.0 on some systems.
##            A fix is on the way.
## =======================================================================

## a stiff equation, exponential decay, run 500 times
stiff &lt;- function(t, y, p) {   # y and r are a 500-valued vector
  list(- r * y)
}

N    &lt;- 500
r    &lt;- runif(N, 15, 20)
yini &lt;- runif(N, 1, 40)

times &lt;- 0:10

## Using the default
print(system.time(
  out &lt;- ode(y = yini, parms = NULL, times = times, func = stiff)
))
# diagnostics(out) shows that the method used = bdf (2), so it it stiff

## Specify that the Jacobian is banded, with nonzero values on the 
## diagonal, i.e. the bandwidth up and down = 0 

print(system.time(
  out2 &lt;- ode(y = yini, parms = NULL, times = times, func = stiff,
              jactype = "bandint", bandup = 0, banddown = 0)
))

## Now we also specify the Jacobian function

jacob &lt;- function(t, y, p) -r

print(system.time(
  out3 &lt;- ode(y = yini, parms = NULL, times = times, func = stiff, 
              jacfunc = jacob, jactype = "bandusr", 
              bandup = 0, banddown = 0)
))
## The larger the value of N, the larger the time gain...

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
