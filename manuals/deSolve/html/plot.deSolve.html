<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Plot, Image and Histogram Method for deSolve Objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for plot.deSolve {deSolve}"><tr><td>plot.deSolve {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Plot, Image and Histogram Method for deSolve Objects
</h2>

<h3>Description</h3>

<p>Plot the output of numeric integration routines.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'deSolve'
plot(x, ..., select = NULL, which = select, ask = NULL,
              obs = NULL, obspar = list(), subset = NULL)




## S3 method for class 'deSolve'
hist(x, select = 1:(ncol(x)-1), which  = select, ask = NULL,
              subset = NULL, ...)
## S3 method for class 'deSolve'
image(x, select = NULL, which = select, ask = NULL,
              add.contour = FALSE, grid = NULL,
              method = "image", legend = FALSE, subset = NULL, ...)
## S3 method for class 'deSolve'
subset(x, subset = NULL, select = NULL,
             which = select, arr = FALSE, ...)

plot.1D (x, ..., select = NULL, which = select, ask = NULL,
         obs = NULL, obspar = list(), grid = NULL,
         xyswap = FALSE, delay = 0, vertical = FALSE, subset = NULL)

matplot.0D(x, ..., select = NULL, which = select,
           obs = NULL, obspar = list(), subset = NULL,
           legend = list(x = "topright"))

matplot.1D(x, select = NULL, which = select, ask = NULL,
         obs = NULL, obspar = list(), grid = NULL,
         xyswap = FALSE, vertical = FALSE, subset = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x </code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and to be plotted.
</p>
<p>For <code>plot.deSolve</code>, it is allowed to pass several objects of class
<code>deSolve</code> after <code>x</code> (unnamed) - see second example.
</p>
</td></tr>
<tr valign="top"><td><code>which </code></td>
<td>
<p>the name(s) or the index to the variables that should be
plotted or selected.  Default = all variables, except <code>time</code>.
For use with <code>matplot.0D</code> and <code>matplot.1D</code>, <code>which</code> or <code>select</code> can be a list,
with vectors, each referring to a separate y-axis.
</p>
</td></tr>
<tr valign="top"><td><code>select </code></td>
<td>
<p>which variable/columns to be selected.  This is added for
consistency with the R-function <code>subset</code>.
</p>
</td></tr>
<tr valign="top"><td><code>subset </code></td>
<td>
<p>either a logical expression indicating elements or rows to keep in
<code>select</code>, or a vector of integers denoting the indices of the elements
over which to loop. Missing  values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr valign="top"><td><code>ask </code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, if <code>NULL</code> the user is only asked if more than one
page of plots is necessary and the current graphics device is set
interactive, see <code><a href="../../graphics/html/par.html">par</a>(ask)</code> and
<code><a href="../../grDevices/html/dev.interactive.html">dev.interactive</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>add.contour </code></td>
<td>
<p>if <code>TRUE</code>, will add contours to the image plot.</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the name of the plotting method to use, one of &quot;image&quot;,
&quot;filled.contour&quot;, &quot;persp&quot;, &quot;contour&quot;.</p>
</td></tr>
<tr valign="top"><td><code>grid </code></td>
<td>
<p>only for <code>image</code> plots and for <code>plot.1D</code>:
the 1-D grid as a vector (for output generated with <code>ode.1D</code>),
or the x- and y-grid, as a <code>list</code> (for output generated with
<code>ode.2D</code>).</p>
</td></tr>
<tr valign="top"><td><code>xyswap </code></td>
<td>
<p>if <code>TRUE</code>, then x-and y-values are swapped and the
y-axis is from top to bottom. Useful for drawing vertical profiles.</p>
</td></tr>
<tr valign="top"><td><code>vertical </code></td>
<td>
<p>if <code>TRUE</code>, then 1. x-and y-values are swapped, the
y-axis is from top to bottom, the x-axis is on top, margin 3 and the
main title gets the value of the x-axis.
Useful for drawing vertical profiles; see example 2.</p>
</td></tr>
<tr valign="top"><td><code>delay </code></td>
<td>
<p>adds a delay (in milliseconds) between consecutive plots
of <code>plot.1D</code> to enable animations.</p>
</td></tr>
<tr valign="top"><td><code>obs </code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> with &quot;observed data&quot; that
will be added as <code>points</code> to the plots. <code>obs</code> can also be a
<code>list</code> with multiple data.frames and/or matrices containing
observed data.
</p>
<p>By default the first column of an observed data set should contain
the <code>time</code>-variable.   The other columns contain the observed values
and they should have names that are known in <code>x</code>.
</p>
<p>If the first column of <code>obs</code> consists of factors or characters (strings),
then it is assumed that the data are presented in long (database) format,
where the first three columns contain (name, time, value).
</p>
<p>If <code>obs</code> is not <code>NULL</code> and <code>which</code> is <code>NULL</code>,
then the variables, common to both <code>obs</code> and <code>x</code> will be plotted.
</p>
</td></tr>
<tr valign="top"><td><code>obspar </code></td>
<td>
<p>additional graphics arguments passed to <code>points</code>, for
plotting the observed data. If <code>obs</code> is a <code>list</code> containing multiple
observed data sets, then the graphics arguments can be  a vector
or a list (e.g. for <code>xlim</code>, <code>ylim</code>), specifying each data set
separately.
</p>
</td></tr>
<tr valign="top"><td><code>legend </code></td>
<td>
<p>if <code>TRUE</code>, a color legend will be drawn on the right
of each image.
For use with <code>matplot.0D</code> and <code>matplot.1D</code>:
a <code>list</code> with arguments passed to R-function <a href="../../graphics/html/legend.html">legend</a>.
</p>
</td></tr>
<tr valign="top"><td><code>arr </code></td>
<td>
<p>if <code>TRUE</code>, and the output is from a 2-D or 3-D model,
an array will be returned with dimension =
c(dimension of selected variable, nrow(x)).
When <code>arr=TRUE</code> then only one variable can be selected.
When the output is from a 0-D or 1-D model, then this argument is ignored.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional arguments.
</p>
<p>The graphical arguments are passed to
<code><a href="../../graphics/html/plot.default.html">plot.default</a></code>, <code><a href="../../graphics/html/image.html">image</a></code> or <code><a href="../../graphics/html/hist.html">hist</a></code>
</p>
<p>For <code>plot.deSolve</code>, and <code>plot.1D</code>, the dots may contain other objects of class
<code>deSolve</code>, as returned by the integrators, and
to be plotted on the same graphs as <code>x</code>  - see second example.
In this case, <code>x</code> and and these other objects should be compatible,
i.e. the column names should be the same.
</p>
<p>For <code>plot.deSolve</code>, the arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of panels per page is automatically determined up to 3 x 3
(<code>par(mfrow = c(3, 3))</code>). This default can be overwritten by
specifying user-defined settings for <code>mfrow</code> or <code>mfcol</code>.
Set <code>mfrow</code> equal to <code>NULL</code> to avoid the plotting function to
change user-defined <code>mfrow</code> or <code>mfcol</code> settings.
</p>
<p>Other graphical parameters can be passed as well. Parameters are
vectorized, either according to the number of plots (<code>xlab</code>,
<code>ylab</code>, <code>main</code>, <code>sub</code>, <code>xlim</code>, <code>ylim</code>,
<code>log</code>, <code>asp</code>, <code>ann</code>, <code>axes</code>, <code>frame.plot</code>,
<code>panel.first</code>, <code>panel.last</code>, <code>cex.lab</code>,
<code>cex.axis</code>, <code>cex.main</code>) or according to the number of lines
within one plot (other parameters e.g. <code>col</code>, <code>lty</code>,
<code>lwd</code> etc.) so it is possible to assign specific axis labels to
individual plots, resp. different plotting style. Plotting parameter
<code>ylim</code>, or <code>xlim</code> can also be a list to assign different
axis limits to individual plots.
</p>
<p>Similarly, the graphical parameters for observed data, as passed by
<code>obspar</code> can be vectorized, according to the number of observed
data sets.
</p>
<p>Image plots will only work for 1-D and 2-D variables, as solved with
<code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> and <code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code>. In the first case, an
image with <code>times</code> as x- and the <code>grid</code> as y-axis will be
created.  In the second case, an x-y plot will be created, for all
times. Unless <code>ask = FALSE</code>, the user will be asked to confirm
page changes.  Via argument <code>mtext</code>, it is possible to label each
page in case of 2D output.
</p>
<p>For images, it is possible to pass an argument
<code>method</code> which can take the values &quot;image&quot; (default),
&quot;filled.contour&quot;, &quot;contour&quot; or &quot;persp&quot;, in order to use the respective
plotting method.
</p>
<p><code>plot</code> and <code>matplot.0D</code> will always have <code>times</code> on the x-axis.
For problems solved with <code>ode.1D</code>, it may be more useful to use
<code>plot.1D</code> or <code>matplot.1D</code>
which will plot how spatial variables change with time. These plots will
have the <code>grid</code> on the x-axis.
</p>


<h3>Value</h3>

<p>Function <code>subset</code> called with <code>arr = FALSE</code> will return a
matrix with up to as many rows as selected by <code>subset</code> and as
many columns as selected variables.
</p>
<p>When <code>arr = TRUE</code> then an array will be outputted with dimensions
equal to the dimension of the selected variable, augmented with the number
of rows selected by <code>subset</code>.  This means that the last dimension points
to <code>times</code>.
</p>
<p>Function <code>subset</code> also has an attribute that contains the <code>times</code>
selected.
</p>


<h3>See Also</h3>

<p><code><a href="../../deSolve/help/deSolve.html">deSolve</a></code>, <code><a href="../../deSolve/help/ode.html">ode</a></code>, <code><a href="../../deSolve/help/print.deSolve.html">print.deSolve</a></code>,
</p>
<p><code><a href="../../graphics/help/hist.html">hist</a></code>
<code><a href="../../graphics/help/image.html">image</a></code>
<code><a href="../../graphics/help/matplot.html">matplot</a></code>,
<code><a href="../../graphics/help/plot.html">plot</a>.default</code>
for the underlying functions from package <span class="pkg">graphics</span>,
</p>
<p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code>, for an example of using <code>subset</code> with
<code>arr = TRUE</code>.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## Example 1. A Predator-Prey model with 4 species in matrix formulation
## =======================================================================

LVmatrix &lt;- function(t, n, parms) {
  with(parms, {
    dn &lt;- r * n + n * (A %*% n)
    return(list(c(dn)))
  })
}
parms &lt;- list(
  r = c(r1 = 0.1, r2 = 0.1, r3 = -0.1, r4 = -0.1),
  A = matrix(c(0.0, 0.0, -0.2, 0.01,      # prey 1
               0.0, 0.0, 0.02, -0.1,      # prey 2
               0.2, 0.02, 0.0, 0.0,       # predator 1; prefers prey 1
               0.01, 0.1, 0.0, 0.0),      # predator 2; prefers prey 2
               nrow = 4, ncol = 4, byrow=TRUE)
)
times &lt;- seq(from = 0, to = 500, by = 0.1)
y     &lt;- c(prey1 = 1, prey2 = 1, pred1 = 2, pred2 = 2)

out &lt;- ode(y, times, LVmatrix, parms)

## Basic line plot
plot(out, type = "l")

## User-specified axis labels
plot(out, type = "l", ylab = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
  xlab = "Time (d)", main = "Time Series")

## Set user-defined mfrow
pm &lt;- par (mfrow = c(2, 2))

## "mfrow=NULL" keeps user-defined mfrow
plot(out, which = c("prey1", "pred2"), mfrow = NULL, type = "l", lwd = 2)

plot(out[,"prey1"], out[,"pred1"], xlab="prey1",
  ylab = "pred1", type = "l", lwd = 2)
plot(out[,"prey2"], out[,"pred2"], xlab = "prey2",
  ylab = "pred2", type = "l",lwd = 2)

## restore graphics parameters
par ("mfrow" = pm)

## Plot all in one figure, using matplot
matplot.0D(out, lwd = 2)

## Split y-variables in two groups
matplot.0D(out, which = list(c(1,3), c(2,4)),
           lty = c(1,2,1,2), col=c(4,4,5,5),
           ylab = c("prey1,pred1", "prey2,pred2"))

## =======================================================================
## Example 2. Add second and third output, and observations
## =======================================================================

# New runs with different parameter settings
parms2      &lt;- parms
parms2$r[1] &lt;- 0.2
out2 &lt;- ode(y, times, LVmatrix, parms2)

# New runs with different parameter settings
parms3      &lt;- parms
parms3$r[1] &lt;- 0.05
out3 &lt;- ode(y, times, LVmatrix, parms3)

# plot all three outputs
plot(out, out2, out3, type = "l",
     ylab = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
     xlab = "Time (d)", main = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
     col = c("red", "blue", "darkred"))


## 'observed' data
obs &lt;- as.data.frame(out[out[,1] %in% seq(10, 500, by = 30), ])

plot(out, which = "prey1", type = "l", obs = obs,
     obspar = list(pch = 18, cex = 2))

plot(out, type = "l", obs = obs, col = "red")

matplot.0D(out, which = c("prey1", "pred1"), type = "l", obs = obs)

## second set of 'observed' data and two outputs
obs2 &lt;- as.data.frame(out2[out2[,1] %in% seq(10, 500, by = 50), ])

## manual xlim, log
plot(out, out2, type = "l", obs = list(obs, obs2), col = c("red", "blue"),
      obspar = list(pch = 18:19, cex = 2, col = c("red", "blue")),
      log = c("y", ""), which = c("prey1", "prey1"),
      xlim = list(c(100, 500), c(0, 400)))

## data in 'long' format
OBS &lt;- data.frame(name = c(rep("prey1", 3), rep("prey2", 2)),
                  time = c(10, 100, 250, 10, 400),
                  value = c(0.05, 0.04, 0.7, 0.5, 1))
OBS
plot(out, obs = OBS, obspar = c(pch = 18, cex = 2))

# a subset only:
plot(out, subset = prey1 &lt; 0.5, type = "p")

# Simple histogram
hist(out, col = "darkblue", breaks = 50)

hist(out, col = "darkblue", breaks = 50, subset = prey1&lt;1 &amp; prey2 &lt; 1)

# different parameters per plot
hist(out, col = c("darkblue", "red", "orange", "black"),
     breaks = c(10,50))

## =======================================================================
## The Aphid model from Soetaert and Herman, 2009.
## A practical guide to ecological modelling.
## Using R as a simulation platform. Springer.
## =======================================================================

## 1-D diffusion model

## ================
## Model equations
## ================
Aphid &lt;- function(t, APHIDS, parameters) {
  deltax  &lt;- c (0.5*delx, rep(delx, numboxes - 1), 0.5*delx)
  Flux    &lt;- -D * diff(c(0, APHIDS, 0))/deltax
  dAPHIDS &lt;- -diff(Flux)/delx + APHIDS * r
  list(dAPHIDS, Flux = Flux)
}

## ==================
## Model application
## ==================

## the model parameters:
D         &lt;- 0.3    # m2/day  diffusion rate
r         &lt;- 0.01   # /day    net growth rate
delx      &lt;- 1      # m       thickness of boxes
numboxes  &lt;- 60

## distance of boxes on plant, m, 1 m intervals
Distance  &lt;- seq(from = 0.5, by = delx, length.out = numboxes)

## Initial conditions, ind/m2
## aphids present only on two central boxes
APHIDS        &lt;- rep(0, times = numboxes)
APHIDS[30:31] &lt;- 1
state         &lt;- c(APHIDS = APHIDS)      # initialise state variables

## RUNNING the model:
times &lt;- seq(0, 200, by = 1)   # output wanted at these time intervals
out   &lt;- ode.1D(state, times, Aphid, parms = 0, nspec = 1, names = "Aphid")

image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  legend = TRUE)

## restricting time
image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  legend = TRUE, subset = time &lt; 100)

image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  method = "persp", border = NA, theta = 30)

FluxAphid &lt;- subset(out, select = "Flux", subset = time &lt; 50)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1,
           subset = time &lt; 50)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1,
           subset = time %in% seq(0, 200, by = 10), col = "grey")

## Not run: 
  plot(out, ask = FALSE, mfrow = c(1, 1))
  plot.1D(out, ask = FALSE, type = "l", lwd = 2, xyswap = TRUE)

## End(Not run)

## see help file for ode.2D for images of 2D variables
</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
