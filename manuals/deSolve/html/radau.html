<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Implicit Runge-Kutta RADAU IIA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for radau {deSolve}"><tr><td>radau {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Implicit Runge-Kutta RADAU IIA</h2>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of
ordinary differential equations (ODE) in the form: </p>
<p style="text-align: center;"><i>dy/dt = 
  f(t,y)</i></p>
<p> or linearly implicit differential algebraic equations in the 
form: </p>
<p style="text-align: center;"><i>M dy/dt = f(t,y)</i></p>
<p>.
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>radau</code> provides an interface to the Fortran solver 
RADAU5, written by Ernst Hairer and G. Wanner, which implements the 3-stage
RADAU IIA method.
It implements the implicit Runge-Kutta method of order 5 with step size 
control and continuous output.
The system of ODEs or DAEs is written as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function or can be defined in
compiled code that has been dynamically loaded.
</p>


<h3>Usage</h3>

<pre>
radau(y, times, func, parms, nind = c(length(y), 0, 0), 
  rtol = 1e-6, atol = 1e-6, jacfunc = NULL, jactype = "fullint", 
  mass = NULL, massup = NULL, massdown = NULL, rootfunc = NULL,
  verbose = FALSE, nroot = 0, hmax = NULL, hini = 0, ynames = TRUE,
  bandup = NULL, banddown = NULL, maxsteps = 5000, 
  dllname = NULL, initfunc = dllname, initpar = parms, 
  rpar = NULL, ipar = NULL, nout = 0, outnames = NULL, 
  forcings = NULL, initforc = NULL, fcontrol = NULL,
  events=NULL, lags = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or the right-hand side of the equation </p>
<p style="text-align: center;"><i>M dy/dt = f(t,y)</i></p>

<p>if a DAE. (if <code>mass</code> is supplied then the problem is assumed a DAE).
</p>
<p><code>func</code> can also be a character string giving the name of a compiled 
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
</p>
<p><code>func &lt;- function(t, y, parms,...)</code>.
</p>
<p><code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>radau()</code> is called. See deSolve package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nind </code></td>
<td>
<p>if a DAE system: a three-valued vector with the number of
variables of index 1, 2, 3 respectively.
The equations must be defined such that the index 1 variables precede
the index 2 variables which in turn precede the index 3 variables.
The sum of the variables of different index should equal N,
the total number of variables.
This has implications on the scaling of the variables,
i.e. index 2 variables are scaled by 1/h,
index 3 variables are scaled by 1/h^2. 
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance, either a
scalar or an array as long as <code>y</code>. See details.
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr valign="top"><td><code>jacfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes the
Jacobian of the system of differential equations
<i>dydot(i)/dy(j)</i>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> from package deSolve, for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix,
<code>jacfunc</code> should return a matrix
<i>dydot/dy</i>, where the ith row
contains the derivative of <i>dy_i/dt</i> with respect to <i>y_j</i>,
or a vector containing the matrix elements by columns (the way <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
and FORTRAN store matrices).  <br /> If the Jacobian is banded,
<code>jacfunc</code> should return a matrix containing only the nonzero
bands of the Jacobian, rotated row-wise. See example.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user.
</p>
</td></tr>
<tr valign="top"><td><code>mass </code></td>
<td>
<p>the mass matrix. 
If not <code>NULL</code>, the problem is a linearly
implicit DAE and defined as <i>M dy/dt = f(t,y)</i>.
If the mass-matrix <i>M</i> is full, it should be of dimension
<i>n*n</i> where <i>n</i> is the number of <i>y</i>-values;
if banded the number of rows should be less than <i>n</i>,
and the mass-matrix is stored diagonal-wise with element <i>(i, j)</i>
stored in <code>mass(i - j + mumas + 1, j)</code>.
</p>
<p>If <code>mass = NULL</code> then the model is an ODE (default)  
</p>
</td></tr>
<tr valign="top"><td><code>massup </code></td>
<td>
<p>number of non-zero bands above the diagonal of the <code>mass</code> 
matrix, in case it is banded.
</p>
</td></tr>
<tr valign="top"><td><code>massdown </code></td>
<td>
<p>number of non-zero bands below the diagonal of the <code>mass</code> 
matrix, in case it is banded.
</p>
</td></tr>
<tr valign="top"><td><code>rootfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr valign="top"><td><code>nroot </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is set equal to 1e-6. Usually 1e-3 to 1e-5 is good for stiff equations
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>logical, if <code>FALSE</code> names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for multi-D models.
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>average maximal number of steps per output interval
taken by the solver. This argument is defined such as to ensure
compatibility with the Livermore-solvers. RADAU only accepts the maximal
number of steps for the entire integration, and this is calculated 
as <code>length(times) * maxsteps</code>.
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculed in the DLL - you have
to perform this check in the code - See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time, value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="../../deSolve/help/forcings.html">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>events </code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a
state variable is suddenly changed. See <a href="../../deSolve/help/events.html">events</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>lags </code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps
that has to be kept. To be used for delay differential equations.
See <a href="../../deSolve/help/timelags.html">timelags</a>, <a href="../../deSolve/help/dede.html">dede</a> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the FORTRAN subroutine <code>RADAU5</code>, whose
documentation should be consulted for details. The implementation
is based on the Fortran 77 version from January 18, 2002.
</p>
<p>There are four standard choices for the Jacobian which can be specified with
<code>jactype</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<dl>
<dt>jactype = &quot;fullint&quot;</dt><dd><p>a full Jacobian, calculated internally by
the solver.
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code>.
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code>; the size of the bands specified by
<code>bandup</code> and <code>banddown</code>.
</p>
</dd>
<dt>jactype = &quot;bandint&quot;</dt><dd><p>a banded Jacobian, calculated by radau;
the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</dd>
</dl>

<p>Inspection of the example below shows how to specify both a banded and
full Jacobian.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver, which roughly keeps the 
local error of <i>y(i)</i> below <i>rtol(i)*abs(y(i))+atol(i)</i>.  
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will be written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) from the <code>deSolve</code> package for an 
explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> from package 
<code>deSolve</code> for details.
</p>
<p>Information about linking forcing functions to compiled code is in 
<a href="../../deSolve/help/forcings.html">forcings</a> (from package <code>deSolve</code>).
</p>
<p><code>radau</code> can find the root of at least one of a set of constraint functions
<code>rootfunc</code> of the independent and dependent variables.  It then returns the
solution at the root if that occurs sooner than the specified stop
condition, and otherwise returns the solution according the specified
stop condition.
</p>
<p>Caution:  Because of numerical errors in the function
<code>rootfun</code> due to roundoff and integration error, <code>radau</code> may
return false roots, or return the same root at two or more
nearly equal values of <code>time</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine 
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert 
</p>


<h3>References</h3>

<p>E. Hairer and G. Wanner, 1996. Solving Ordinary Differential Equations II.
Stiff and Differential-algebraic problems. Springer series in computational
mathematics 14, Springer-Verlag, second edition.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers ,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/daspk.html">daspk</a></code> for integrating DAE models up to index 1
</p>
</li></ul>

<p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre>
## =======================================================================
## Example 1: ODE
##   Various ways to solve the same model.
## =======================================================================

## the model, 5 state variables
f1 &lt;- function  (t, y, parms) {
  ydot &lt;- vector(len = 5)

  ydot[1] &lt;-  0.1*y[1] -0.2*y[2]
  ydot[2] &lt;- -0.3*y[1] +0.1*y[2] -0.2*y[3]
  ydot[3] &lt;-           -0.3*y[2] +0.1*y[3] -0.2*y[4]
  ydot[4] &lt;-                     -0.3*y[3] +0.1*y[4] -0.2*y[5]
  ydot[5] &lt;-                               -0.3*y[4] +0.1*y[5]

  return(list(ydot))
}

## the Jacobian, written as a full matrix
fulljac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 5, ncol = 5, byrow = TRUE,
                data = c(0.1, -0.2,  0  ,  0  ,  0  ,
                        -0.3,  0.1, -0.2,  0  ,  0  ,
                         0  , -0.3,  0.1, -0.2,  0  ,
                         0  ,  0  , -0.3,  0.1, -0.2,
                         0  ,  0  ,  0  , -0.3,  0.1))
  return(jac)
}

## the Jacobian, written in banded form
bandjac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 3, ncol = 5, byrow = TRUE,
                data = c( 0  , -0.2, -0.2, -0.2, -0.2,
                          0.1,  0.1,  0.1,  0.1,  0.1,
                         -0.3, -0.3, -0.3, -0.3,    0))
  return(jac)
}

## initial conditions and output times
yini  &lt;- 1:5
times &lt;- 1:20

## default: stiff method, internally generated, full Jacobian
out   &lt;- radau(yini, times, f1, parms = 0)
plot(out)

## stiff method, user-generated full Jacobian
out2  &lt;- radau(yini, times, f1, parms = 0, jactype = "fullusr",
               jacfunc = fulljac)

## stiff method, internally-generated banded Jacobian
## one nonzero band above (up) and below(down) the diagonal
out3  &lt;- radau(yini, times, f1, parms = 0, jactype = "bandint",
               bandup = 1, banddown = 1)

## stiff method, user-generated banded Jacobian
out4  &lt;- radau(yini, times, f1, parms = 0, jactype = "bandusr",
               jacfunc = bandjac, bandup = 1, banddown = 1)


## =======================================================================
## Example 2: ODE
##   stiff problem from chemical kinetics
## =======================================================================
Chemistry &lt;- function (t, y, p) {
  dy1 &lt;- -.04*y[1] + 1.e4*y[2]*y[3]
  dy2 &lt;- .04*y[1] - 1.e4*y[2]*y[3] - 3.e7*y[2]^2
  dy3 &lt;- 3.e7*y[2]^2
  list(c(dy1, dy2, dy3))
}

times &lt;- 10^(seq(0, 10, by = 0.1))
yini &lt;- c(y1 = 1.0, y2 = 0, y3 = 0)

out &lt;- radau(func = Chemistry, times = times, y = yini, parms = NULL)
plot(out, log = "x", type = "l", lwd = 2)

## =============================================================================
## Example 3: DAE
## Car axis problem, index 3 DAE, 8 differential, 2 algebraic equations
## from
## F. Mazzia and C. Magherini. Test Set for Initial Value Problem Solvers,
## release 2.4. Department
## of Mathematics, University of Bari and INdAM, Research Unit of Bari,
## February 2008.
## Available at http://www.dm.uniba.it/~testset.
## =============================================================================

## Problem is written as M*y' = f(t,y,p).
## caraxisfun implements the right-hand side:

caraxisfun &lt;- function(t, y, parms) {
  with(as.list(y), {
  
    yb &lt;- r * sin(w * t)
    xb &lt;- sqrt(L * L - yb * yb)
    Ll &lt;- sqrt(xl^2 + yl^2)
    Lr &lt;- sqrt((xr - xb)^2 + (yr - yb)^2)
        
    dxl &lt;- ul; dyl &lt;- vl; dxr &lt;- ur; dyr &lt;- vr
        
    dul  &lt;- (L0-Ll) * xl/Ll      + 2 * lam2 * (xl-xr) + lam1*xb
    dvl  &lt;- (L0-Ll) * yl/Ll      + 2 * lam2 * (yl-yr) + lam1*yb - k * g
               
    dur  &lt;- (L0-Lr) * (xr-xb)/Lr - 2 * lam2 * (xl-xr)
    dvr  &lt;- (L0-Lr) * (yr-yb)/Lr - 2 * lam2 * (yl-yr) - k * g
        
    c1   &lt;- xb * xl + yb * yl
    c2   &lt;- (xl - xr)^2 + (yl - yr)^2 - L * L
        
    list(c(dxl, dyl, dxr, dyr, dul, dvl, dur, dvr, c1, c2))
  })
}

eps &lt;- 0.01; M &lt;- 10; k &lt;- M * eps^2/2; 
L &lt;- 1; L0 &lt;- 0.5; r &lt;- 0.1; w &lt;- 10; g &lt;- 1

yini &lt;- c(xl = 0, yl = L0, xr = L, yr = L0,
          ul = -L0/L, vl = 0,
          ur = -L0/L, vr = 0,
          lam1 = 0, lam2 = 0)

# the mass matrix
Mass      &lt;- diag(nrow = 10, 1)
Mass[5,5] &lt;- Mass[6,6] &lt;- Mass[7,7] &lt;- Mass[8,8] &lt;- M * eps * eps/2
Mass[9,9] &lt;- Mass[10,10] &lt;- 0
Mass

# index of the variables: 4 of index 1, 4 of index 2, 2 of index 3
index &lt;- c(4, 4, 2)

times &lt;- seq(0, 3, by = 0.01)
out &lt;- radau(y = yini, mass = Mass, times = times, func = caraxisfun,
        parms = NULL, nind = index)

plot(out, which = 1:4, type = "l", lwd = 2)
</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.28 <a href="00Index.html">Index</a>]</div>
</body></html>
