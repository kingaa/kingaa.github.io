<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Explicit One-Step Solvers for Ordinary Differential Equations...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for rk {deSolve}"><tr><td>rk {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Explicit One-Step Solvers for Ordinary Differential Equations
(ODE)</h2>

<h3>Description</h3>

<p>Solving initial value problems for non-stiff systems of
first-order ordinary differential equations (ODEs).
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>rk</code> is a top-level function that provides
interfaces to a collection of common explicit one-step solvers of the
Runge-Kutta family with fixed or variable time steps.
</p>
<p>The system of ODE's is written as an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function (which may, of
course, use <code><a href="../../base/html/Foreign.html">.C</a></code>, <code><a href="../../base/html/Foreign.html">.Fortran</a></code>,
<code><a href="../../base/html/CallExternal.html">.Call</a></code>, etc., to call foreign code) or be defined in
compiled code that has been dynamically loaded.  A vector of
parameters is passed to the ODEs, so the solver may be used as part of
a modeling package for ODEs, or for parameter estimation using any
appropriate modeling tool for non-linear models in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> such as
<code><a href="../../stats/html/optim.html">optim</a></code>, <code><a href="../../stats/html/nls.html">nls</a></code>, <code><a href="../../stats/html/nlm.html">nlm</a></code> or
<code><a href="../../nlme/help/nlme.html">nlme</a></code>
</p>


<h3>Usage</h3>

<pre>
rk(y, times, func, parms, rtol = 1e-6, atol = 1e-6,
  verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL,
  hini = hmax, ynames = TRUE, method = rkMethod("rk45dp7", ... ),
  maxsteps = 5000, dllname = NULL, initfunc = dllname,
  initpar = parms, rpar = NULL, ipar = NULL,
  nout = 0, outnames = NULL, forcings = NULL,
  initforc = NULL, fcontrol = NULL, events = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>rk</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code>.
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>. Only applicable to methods with variable time
step, see details.
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. Only applicable to methods with variable time
step, see details.
</p>
</td></tr>
<tr valign="top"><td><code>tcrit </code></td>
<td>
<p>if not <code>NULL</code>, then <code>rk</code> cannot integrate past
<code>tcrit</code>. This parameter is for compatibility with other solvers.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>a logical value that, when TRUE, triggers more
verbose output from the ODE solver.
</p>
</td></tr>
<tr valign="top"><td><code>hmin </code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the maximum of <code>hini</code> and
the largest difference in <code>times</code>, to avoid that the simulation
possibly ignores short-term events.  If 0, no maximal size is
specified. Note that <code>hmin</code> and <code>hmax</code> are ignored by
fixed step methods like <code>"rk4"</code> or <code>"euler"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined automatically by solvers with flexible time step.
For fixed step methods, setting <code>hini = 0</code> forces 
internal time steps identically to external time steps provided by
<code>times</code>. Similarly, internal time steps of non-interpolating
solvers cannot be bigger than external time steps specified in <code>times</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>if <code>FALSE</code>: names of state variables are not passed
to function <code>func</code> ; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr valign="top"><td><code>method </code></td>
<td>
<p>the integrator to use. This can either be a string
constant naming one of the pre-defined methods or a call to function
<code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code> specifying a user-defined method.  The most
common methods are the fixed-step methods <code>"euler"</code>, second and
fourth-order Runge Kutta (<code>"rk2"</code>, <code>"rk4"</code>), or the
variable step methods Bogacki-Shampine <code>"rk23bs"</code>,
Runge-Kutta-Fehlberg <code>"rk34f"</code>, the fifth-order Cash-Karp
method <code>"rk45ck"</code> or the fifth-order Dormand-Prince method with
seven stages <code>"rk45dp7"</code>.
As a suggestion, one may use <code>"rk23bs"</code> (alias <code>"ode23"</code>) for
simple problems and <code>"rk45dp7"</code> (alias <code>"ode45"</code>) for
rough problems.
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>average maximal number of steps per output interval
taken by the solver. This argument is defined such as to ensure
compatibility with the Livermore-solvers. <code>rk</code> only accepts the maximal
number of steps for the entire integration. It is calculated 
as <code>max(length(times) * maxsteps, max(diff(times)/hini + 1)</code>.
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="../../deSolve/help/forcings.html">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>events </code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="../../deSolve/help/events.html">events</a> for more information.
Not also that if events are specified, then polynomial interpolation
is switched off and integration takes place from one external time step 
to the next, with an internal step size less than or equal the difference
of two adjacent points of <code>times</code>.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code> allowing this
to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rk</code> is a generalized implementation that can be used to
evaluate different solvers of the Runge-Kutta family of explicit ODE
solvers. A pre-defined set of common method parameters is in function
<code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code> which also allows to supply user-defined
Butcher tables.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the error
control performed by the solver.  The solver will control the vector
of estimated local errors in <b>y</b>, according to an inequality of
the form max-norm of ( <b>e</b>/<b>ewt</b> ) <i> &lt;= </i> 1, where
<b>ewt</b> is a vector of positive error weights.  The values of
<code>rtol</code> and <code>atol</code> should all be non-negative.  The form of
<b>ewt</b> is:
</p>
<p style="text-align: center;"><i>\bold{rtol} * abs(\bold{y}) + \bold{atol}</i></p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p><b>Models</b> can be defined in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> as a user-supplied
<b>R-function</b>, that must be called as: <code>yprime = func(t, y,
  parms)</code>.  <code>t</code> is the current time point in the integration,
<code>y</code> is the current estimate of the variables in the ODE system.
</p>
<p>The return value of <code>func</code> should be a list, whose first element
is a vector containing the derivatives of <code>y</code> with respect to
time, and whose second element contains output variables that are
required at each point in time. Examples are given below.  
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the
number of &quot;global&quot; values returned in the next elements of the return
from <code>func</code>, plus and additional column for the time value.
There will be a row for each element in <code>times</code> unless the
integration routine returns with an unrecoverable error. If <code>y</code>
has a names attribute, it will be used to label the columns of the
output value.
</p>


<h3>Note</h3>

  
<p>Arguments <code>rpar</code> and <code>ipar</code> are provided for compatibility
with <code>lsoda</code>.
</p>
<p>Starting with version 1.8 implicit Runge-Kutta methods are also
supported by this general <code>rk</code> interface, however their
implementation is still experimental.  Instead of this you may
consider <code><a href="../../deSolve/help/radau.html">radau</a></code> for a specific full implementation of an
implicit Runge-Kutta method.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a></p>


<h3>References</h3>

<p>Butcher, J. C. (1987) The numerical analysis of ordinary differential
equations, Runge-Kutta and general linear methods, Wiley, Chichester
and New York.
</p>
<p>Engeln-Muellges, G. and Reutter, F. (1996) Numerik Algorithmen:
Entscheidungshilfe zur Auswahl und Nutzung. VDI Verlag, Duesseldorf.
</p>
<p>Hindmarsh, Alan C. (1983) ODEPACK, A Systematized Collection of ODE
Solvers; in p.55&ndash;64 of Stepleman, R.W. et al.[ed.] (1983)
<em>Scientific Computing</em>, North-Holland, Amsterdam.
</p>
<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery,
B. P. (2007) Numerical Recipes in C. Cambridge University Press.
</p>


<h3>See Also</h3>

  
<p>For most practical cases, solvers of the Livermore family (i.e. the
ODEPACK solvers, see below) are superior. Some of them are also
suitable for stiff ODEs, differential algebraic equations (DAEs), or
partial differential equations (PDEs).
</p>

<ul>
<li> <p><code><a href="../../deSolve/help/rkMethod.html">rkMethod</a></code> for a list of available Runge-Kutta
parameter sets,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/rk4.html">rk4</a></code> and <code><a href="../../deSolve/help/euler.html">euler</a></code> for special
versions without interpolation (and less overhead),
</p>
</li>
<li> <p><code><a href="../../deSolve/help/lsoda.html">lsoda</a></code>, <code><a href="../../deSolve/help/lsode.html">lsode</a></code>,
<code><a href="../../deSolve/help/lsodes.html">lsodes</a></code>, <code><a href="../../deSolve/help/lsodar.html">lsodar</a></code>, <code><a href="../../deSolve/help/vode.html">vode</a></code>,
<code><a href="../../deSolve/help/daspk.html">daspk</a></code> for solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.html">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.band.html">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.1D.html">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.2D.html">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/ode.3D.html">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="../../deSolve/help/diagnostics.html">diagnostics</a></code> to print diagnostic messages.
</p>
</li></ul>



<h3>Examples</h3>

<pre>
## =======================================================================
## Example: Resource-producer-consumer Lotka-Volterra model
## =======================================================================

## Notes:
## - Parameters are a list, names accessible via "with" function
## - Function sigimp passed as an argument (input) to model
##  (see also ode and lsoda examples)

SPCmod &lt;- function(t, x, parms, input)  {
  with(as.list(c(parms, x)), {
    import &lt;- input(t)
    dS &lt;- import - b*S*P + g*C    # substrate
    dP &lt;- c*S*P  - d*C*P          # producer
    dC &lt;- e*P*C  - f*C            # consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## The parameters 
parms &lt;- c(b = 0.001, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times &lt;- seq(0, 200, length = 101)

## external signal with rectangle impulse
signal &lt;- data.frame(times = times,
                     import = rep(0, length(times)))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)

## Start values for steady state
xstart &lt;- c(S = 1, P = 1, C = 1)

## Euler method
out1  &lt;- rk(xstart, times, SPCmod, parms, hini = 0.1, 
            input = sigimp, method = "euler")

## classical Runge-Kutta 4th order
out2 &lt;- rk(xstart, times, SPCmod, parms, hini = 1, 
           input = sigimp, method = "rk4")

## Dormand-Prince method of order 5(4)
out3 &lt;- rk(xstart, times, SPCmod, parms, hmax = 1, 
           input = sigimp, method = "rk45dp7")

mf &lt;- par("mfrow")
## deSolve plot method for comparing scenarios
plot(out1, out2, out3, which = c("S", "P", "C"), 
     main = c ("Substrate", "Producer", "Consumer"),
     col =c("black", "red", "green"), 
     lty = c("solid", "dotted", "dotted"), lwd = c(1, 2, 1))

## user-specified plot function
plot (out1[,"P"], out1[,"C"], type = "l", xlab = "Producer", ylab = "Consumer")
lines(out2[,"P"], out2[,"C"], col = "red",   lty = "dotted", lwd = 2)
lines(out3[,"P"], out3[,"C"], col = "green", lty = "dotted")

legend("center", legend = c("euler", "rk4", "rk45dp7"),
  lty = c(1, 3, 3), lwd = c(1, 2, 1),
  col = c("black", "red", "green"))
par(mfrow = mf)
</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
