<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Collection of Parameter Sets (Butcher Arrays) for the...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for rkMethod {deSolve}"><tr><td>rkMethod {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Collection of Parameter Sets (Butcher Arrays) for
the Runge-Kutta Family of ODE Solvers
</h2>

<h3>Description</h3>

<p>This function returns a list specifying coefficients and properties of
ODE solver methods from the Runge-Kutta family.
</p>


<h3>Usage</h3>

<pre>
rkMethod(method = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>method </code></td>
<td>
<p>a string constant naming one of the pre-defined methods
of the Runge-Kutta family of solvers.  The most common methods are
the fixed-step methods <code>"euler"</code>, <code>"rk2"</code>, <code>"rk4"</code> or
the variable step methods <code>"rk23bs"</code> (alias <code>"ode23"</code>),
<code>"rk45dp7"</code> (alias <code>"ode45"</code>) or <code>"rk78f"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>specification of a user-defined solver, see <em>Value</em>
and example below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supplies <code>method</code> settings for <code><a href="../../deSolve/help/rk.html">rk</a></code> or
<code><a href="../../deSolve/help/ode.html">ode</a></code>. If called without arguments, the names of all
currently implemented solvers of the Runge-Kutta family are returned.
</p>
<p>The following comparison gives an idea how the algorithms of <span class="pkg">deSolve</span>
are related to similar algorithms of other simulation languages:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
    <b>rkMethod</b>    </td><td style="text-align: left;"> | </td><td style="text-align: left;"> <b>Description</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    "euler"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Euler's Method</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk2"              </td><td style="text-align: left;"> | </td><td style="text-align: left;"> 2nd order Runge-Kutta, fixed time step (Heun's method)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk4"              </td><td style="text-align: left;"> | </td><td style="text-align: left;"> classical 4th order Runge-Kutta, fixed time step</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk23"             </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta, order 2(3); Octave: ode23</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk23bs", "ode23"  </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Bogacki-Shampine, order 2(3); Matlab: ode23</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk34f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 3(4)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45ck"           </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta Cash-Karp, order 4(5)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 4(5); Octave: ode45, pair=1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45e"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-England, order 4(5)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45dp6"          </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince, order 4(5), local order 6</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45dp7", "ode45" </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince 4(5), local order 7 </td>
</tr>
<tr>
 <td style="text-align: left;">
                       </td><td style="text-align: left;"> | </td><td style="text-align: left;"> (also known as dopri5; MATLAB: ode45; Octave: ode45, pair=0)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk78f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 7(8)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk78dp"           </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince, order 7(8)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Note that this table is based on the Runge-Kutta coefficients only,
but the algorithms differ also in their implementation, in their
stepsize adaption strategy and interpolation methods.
</p>
<p>The table reflects the state at time of writing and it is of course possible
that implementations change.
</p>
<p>Methods <code>"rk45dp7"</code> (alias <code>"ode45"</code>) and <code>"rk45ck"</code> contain
specific and efficient built-in interpolation schemes (dense output).
</p>
<p>As an alternative, Neville-Aitken polynomials can be used to interpolate between
time steps. This is available for all RK methods and may be useful to speed
up computation if no dense-output formula is available. Note however, that
this can introduce considerable local error; it is disabled by default
(see <code>nknots</code> below).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>ID</code></td>
<td>
<p>name of the method (character)</p>
</td></tr>
<tr valign="top"><td><code>varstep</code></td>
<td>
<p>boolean value specifying if the method allows for
variable time step (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</td></tr>
<tr valign="top"><td><code>FSAL</code></td>
<td>
<p>(first same as last) optional boolean value specifying if
the method allows re-use of the last function evaluation
(<code>TRUE</code>) or not (<code>FALSE</code> or <code>NULL</code>).
</p>
</td></tr>
<tr valign="top"><td><code>A</code></td>
<td>
<p>coefficient matrix of the method. As <code>link{rk}</code> supports
only explicit methods, this matrix must be lower triangular.
<code>A</code> must be a vector for fixed step methods where only the
subdiagonal values are different from zero.
</p>
</td></tr>
<tr valign="top"><td><code>b1</code></td>
<td>
<p>coefficients of the lower order Runge-Kutta pair.
</p>
</td></tr>
<tr valign="top"><td><code>b2</code></td>
<td>
<p>coefficients of the higher order Runge-Kutta pair
(optional, for embedded methods that allow variable time step).
</p>
</td></tr>
<tr valign="top"><td><code>c</code></td>
<td>
<p>coefficients for calculating the intermediate time steps.</p>
</td></tr>
<tr valign="top"><td><code>d</code></td>
<td>
<p>optional coefficients for built-in polynomial interpolation
of the outputs from internal steps (dense output), currently only
available for method <code>rk45dp7</code> (Dormand-Prince).
</p>
</td></tr>
<tr valign="top"><td><code>densetype</code></td>
<td>
<p>optional integer value specifying the dense output formula;
currently only <code>densetype = 1</code> for <code>rk45dp7</code> (Dormand-Prince)
and <code>densetype = 2</code> for <code>rk45ck</code> (Cash-Karp) are supported.
Undefined values (e.g., <code>densetype = NULL</code>) disable dense output.
</p>
</td></tr>
<tr valign="top"><td><code>stage</code></td>
<td>
<p>number of function evaluations needed (corresponds to
number of rows in A).
</p>
</td></tr>
<tr valign="top"><td><code>Qerr</code></td>
<td>
<p>global error order of the method, important for automatic
time-step adjustment.
</p>
</td></tr>
<tr valign="top"><td><code>nknots</code></td>
<td>
<p>integer value specifying the order of interpolation
polynomials for methods without dense output.  If <code>nknots</code> &lt; 2
(the default) then internal interpolation is switched off and
integration is performed step by step between external time steps.
</p>
<p>If <code>nknots</code> is between 3 and 8, Neville-Aitken polynomials
are used, which need at least <code>nknots + 1</code> internal time steps.
Interpolation may speed up integration but can lead to local
errors higher than the tolerance, especially if external and
internal time steps are very different.
</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p>optional tuning parameter for stepsize
adjustment. If <code>alpha</code> is omitted, it is set to
<i>1/Qerr - 0.75 beta</i>. The default value is
<i>1/Qerr</i> (for <code>beta</code> = 0).</p>
</td></tr>
<tr valign="top"><td><code>beta</code></td>
<td>
<p>optional tuning parameter for stepsize adjustment. Typical
values are <i>0</i> (default) or <i>0.4/Qerr</i>.
</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> Adaptive stepsize Runge-Kuttas are preferred if the solution
contains parts when the states change fast, and parts when not much
happens. They will take small steps over bumpy ground and long steps
over uninteresting terrain.
</p>
</li>
<li><p> As a suggestion, one may use <code>"rk23"</code> (alias
<code>"ode23"</code>) for simple problems and <code>"rk45dp7"</code> (alias
<code>"ode45"</code>) for rough problems. The default solver is
<code>"rk45dp7"</code> (alias &quot;ode45&quot;), because of its relatively high
order (4), re-use of the last intermediate steps (FSAL = first
same as last) and built-in polynomial interpolation (dense
output).
</p>
</li>
<li><p> Solver <code>"rk23bs"</code>, that supports also FSAL, may be useful for
slightly stiff systems if demands on precision are relatively low.
</p>
</li>
<li><p> Another good choice, assuring medium accuracy, is the Cash-Karp
Runge-Kutta method, <code>"rk45ck"</code>.
</p>
</li>
<li><p> Classical <code>"rk4"</code> is traditionally used in cases where an
adequate stepsize is known a-priori or if external forcing data
are provided for fixed time steps only and frequent interpolation
of external data needs to be avoided.
</p>
</li>
<li><p> Method <code>"rk45dp7"</code> (alias <code>"ode45"</code>) contains an
efficient built-in interpolation scheme (dense output) based on
intermediate function evaluations.
</p>
</li></ul>

<p>Starting with version 1.8 implicit Runge-Kutta (<code>irk</code>) methods
are also supported by the general <code>rk</code> interface, however their
implementation is still experimental.  Instead of this you may
consider <code><a href="../../deSolve/help/radau.html">radau</a></code> for a specific full implementation of an
implicit Runge-Kutta method.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a></p>


<h3>References</h3>

<p>Bogacki, P. and Shampine L.F. (1989) A 3(2) pair of Runge-Kutta
formulas, Appl. Math. Lett. <b>2</b>, 1&ndash;9.
</p>
<p>Butcher, J. C. (1987) The numerical analysis of ordinary differential
equations, Runge-Kutta and general linear methods, Wiley, Chichester
and New York.
</p>
<p>Cash, J. R. and Karp A. H., 1990. A variable order Runge-Kutta method
for initial value problems with rapidly varying right-hand sides,
ACM Transactions on Mathematical Software <b>16</b>, 201&ndash;222.
doi: <a href="https://doi.org/10.1145/79505.79507">10.1145/79505.79507</a>
</p>
<p>Dormand, J. R. and Prince, P. J. (1980) A family of embedded
Runge-Kutta formulae, J. Comput. Appl. Math. <b>6</b>(1), 19&ndash;26.
</p>
<p>Engeln-Muellges, G. and Reutter, F. (1996) Numerik Algorithmen:
Entscheidungshilfe zur Auswahl und Nutzung. VDI Verlag, Duesseldorf.
</p>
<p>Fehlberg, E. (1967) Klassische Runge-Kutta-Formeln fuenfter and
siebenter Ordnung mit Schrittweiten-Kontrolle, Computing
(Arch. Elektron. Rechnen) <b>4</b>, 93&ndash;106.
</p>
<p>Kutta, W. (1901) Beitrag zur naeherungsweisen Integration totaler
Differentialgleichungen, Z. Math. Phys. <b>46</b>, 435&ndash;453.
</p>
<p>Octave-Forge - Extra Packages for GNU Octave, Package OdePkg.
<a href="https://octave.sourceforge.io">https://octave.sourceforge.io</a>
</p>
<p>Prince, P. J.  and Dormand, J. R. (1981) High order embedded
Runge-Kutta formulae, J. Comput. Appl. Math. <b>7</b>(1), 67&ndash;75.
doi: <a href="https://doi.org/10.1016/0771-050X(81)90010-3">10.1016/0771-050X(81)90010-3</a>
</p>
<p>Runge, C. (1895) Ueber die numerische Aufloesung von
Differentialgleichungen, Math. Ann. <b>46</b>, 167&ndash;178.
</p>
<p>MATLAB (R) is a registed property of The Mathworks
Inc. <a href="https://www.mathworks.com/">https://www.mathworks.com/</a> </p>


<h3>See Also</h3>

<p><code><a href="../../deSolve/help/rk.html">rk</a></code>, <code><a href="../../deSolve/help/ode.html">ode</a></code></p>


<h3>Examples</h3>

<pre>
rkMethod()          # returns the names of all available methods
rkMethod("rk45dp7") # parameters of the Dormand-Prince 5(4) method
rkMethod("ode45")   # an alias for the same method

func &lt;- function(t, x, parms) {
  with(as.list(c(parms, x)),{
    dP  &lt;- a * P      - b * C * P
    dC  &lt;- b * P * C  - c * C
    res &lt;- c(dP, dC)
    list(res)
  })
}
times  &lt;- seq(0, 200, length = 101)
parms  &lt;- c(a = 0.1, b = 0.1, c = 0.1)
x &lt;- c(P = 2, C = 1)

## rk using ode45 as the default method
out &lt;- rk(x, times, func, parms)

## all methods can be called also from 'ode' by using rkMethod
out &lt;- ode(x, times, func, parms, method = rkMethod("rk4"))

## 'ode' has aliases for the most common RK methods
out &lt;- ode(x, times, func, parms, method = "ode45")

##===========================================================================
## Comparison of local error from different interpolation methods
##===========================================================================

## lsoda with lower tolerances (1e-10) used as reference
o0 &lt;- ode(x, times, func, parms, method = "lsoda", atol = 1e-10, rtol = 1e-10)

## rk45dp7 with hmax = 10 &gt; delta_t  = 2
o1 &lt;- ode(x, times, func, parms, method = rkMethod("rk45dp7"), hmax = 10)

## disable dense-output interpolation
## and use only Neville-Aitken polynomials instead
o2 &lt;- ode(x, times, func, parms,
  method = rkMethod("rk45dp7", densetype = NULL, nknots = 5), hmax = 10)

## stop and go: disable interpolation completely
## and integrate explicitly between external time steps
o3 &lt;- ode(x, times, func, parms,
  method = rkMethod("rk45dp7", densetype = NULL, nknots = 0, hmax=10))

## compare different interpolation methods with lsoda
mf &lt;- par("mfrow" = c(4, 1))
matplot(o1[,1], o1[,-1], type = "l", xlab = "Time", main = "State Variables",
  ylab = "P, C")
matplot(o0[,1], o0[,-1] - o1[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 with dense output")
abline(h = 0, col = "grey")
matplot(o0[,1], o0[,-1] - o2[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 with Neville-Aitken")
abline(h = 0, col = "grey")
matplot(o0[,1], o0[,-1] - o3[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 in 'stop and go' mode")
abline(h = 0, col = "grey")
par(mf)

##===========================================================================
## rkMethod allows to define user-specified Runge-Kutta methods
##===========================================================================
out &lt;- ode(x, times, func, parms,
          method = rkMethod(ID = "midpoint",
            varstep = FALSE,
            A      = c(0, 1/2),
            b1      = c(0, 1),
            c       = c(0, 1/2),
            stage   = 2,
            Qerr    = 1
          )
        )
plot(out)

## compare method diagnostics
times  &lt;- seq(0, 200, length = 10)
o1 &lt;- ode(x, times, func, parms, method = rkMethod("rk45ck"))
o2 &lt;- ode(x, times, func, parms, method = rkMethod("rk78dp"))
diagnostics(o1)
diagnostics(o2)

</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
