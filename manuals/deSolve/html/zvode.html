<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solver for Ordinary Differential Equations (ODE) for COMPLEX...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for zvode {deSolve}"><tr><td>zvode {deSolve}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Solver for Ordinary Differential Equations (ODE) for COMPLEX variables</h2>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of 
ordinary differential equations (ODE) in the form:
</p>
<p style="text-align: center;"><i>dy/dt = f(t,y)</i></p>

<p>where <i>dy</i> and <i>y</i> are complex variables. 
</p>
<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>zvode</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Peter N. Brown, Alan C. Hindmarsh
and George D. Byrne.
</p>


<h3>Usage</h3>

<pre>zvode(y, times, func, parms, rtol = 1e-6, atol = 1e-6,  
  jacfunc = NULL, jactype = "fullint", mf = NULL, verbose = FALSE,   
  tcrit = NULL, hmin = 0, hmax = NULL, hini = 0, ynames = TRUE,
  maxord = NULL, bandup = NULL, banddown = NULL, maxsteps = 5000,
  dllname = NULL, initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL, forcings = NULL,
  initforc = NULL, fcontrol = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y </code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix. <em>y has to be complex</em>
</p>
</td></tr>
<tr valign="top"><td><code>times </code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times = NULL</code>.
</p>
</td></tr>
<tr valign="top"><td><code>func </code></td>
<td>
<p>either an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
<code>t</code>, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
They should be <em>complex numbers</em>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>zvode()</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr valign="top"><td><code>parms </code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>rtol </code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr valign="top"><td><code>atol </code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr valign="top"><td><code>jacfunc </code></td>
<td>
<p>if not <code>NULL</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that computes the
Jacobian of the system of differential equations
<i>dydot(i)/dy(j)</i>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <i>dydot/dy</i>, where the ith row contains the derivative of
<i>dy_i/dt</i> with respect to <i>y_j</i>, or a vector containing the
matrix elements by columns (the way <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and FORTRAN store matrices).
Its elements should be <em>complex numbers</em>.
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <code>lsode</code>.
</p>
</td></tr>
<tr valign="top"><td><code>jactype </code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user; overruled if <code>mf</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr valign="top"><td><code>mf </code></td>
<td>
<p>the &quot;method flag&quot; passed to function <code>zvode</code> - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see
details.
</p>
</td></tr>
<tr valign="top"><td><code>verbose </code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr valign="top"><td><code>tcrit </code></td>
<td>
<p>if not <code>NULL</code>, then <code>zvode</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>dvode</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr valign="top"><td><code>hmin </code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use hmin if you don't know why!
</p>
</td></tr>
<tr valign="top"><td><code>hmax </code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, hmax is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr valign="top"><td><code>hini </code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr valign="top"><td><code>ynames </code></td>
<td>
<p>logical; if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code> ; this may speed up the simulation
especially for multi-D models.
</p>
</td></tr>
<tr valign="top"><td><code>maxord </code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (<code>meth = 1</code>), order 5 if BDF
method (<code>meth = 2</code>). Reduce maxord to save storage space.
</p>
</td></tr>
<tr valign="top"><td><code>bandup </code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>banddown </code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr valign="top"><td><code>maxsteps </code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr valign="top"><td><code>dllname </code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and <code>jacfunc</code>.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initfunc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr valign="top"><td><code>rpar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the DLL-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ipar </code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr valign="top"><td><code>nout </code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the DLL - you have
to perform this check in the code - See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>outnames </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr valign="top"><td><code>forcings </code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>initforc </code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr valign="top"><td><code>fcontrol </code></td>
<td>
<p>A list of control parameters for the forcing functions.
<a href="../../deSolve/help/forcings.html">forcings</a> or package vignette <code>"compiledCode"</code>
</p>
</td></tr>
<tr valign="top"><td><code>... </code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="../../deSolve/help/vode.html">vode</a></code>, the double precision version, for details.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the 
number of &quot;global&quot; values returned in the next elements of the return 
from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;zvode&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Note</h3>

<p>From version 1.10.4, the default of atol was changed from 1e-8 to 1e-6,
to be consistent with the other solvers.
</p>
<p>The following text is adapted from the zvode.f source code:
</p>
<p>When using <code>zvode</code> for a stiff system, it should only be used for
the case in which the function f is analytic, that is, when each f(i)
is an analytic function of each y(j).  Analyticity means that the
partial derivative df(i)/dy(j) is a unique complex number, and this
fact is critical in the way <code>zvode</code> solves the dense or banded linear
systems that arise in the stiff case.  For a complex stiff ODE system
in which f is not analytic, <code>zvode</code> is likely to have convergence
failures, and for this problem one should instead use <code>ode</code> on the
equivalent real system (in the real and imaginary parts of y).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>P. N. Brown, G. D. Byrne, and A. C. Hindmarsh, 1989.  VODE: A Variable
Coefficient ODE Solver, SIAM J. Sci. Stat. Comput., 10, pp. 1038-1051.
<br /> Also, LLNL Report UCRL-98412, June 1988.
doi: <a href="https://doi.org/10.1137/0910062">10.1137/0910062</a>
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1975. A Polyalgorithm for the
Numerical Solution of Ordinary Differential Equations.  ACM
Trans. Math. Software, 1, pp. 71-96.
doi: <a href="https://doi.org/10.1145/355626.355636">10.1145/355626.355636</a>
</p>
<p>A. C. Hindmarsh and G. D. Byrne, 1977. EPISODE: An Effective Package
for the Integration of Systems of Ordinary Differential
Equations. LLNL Report UCID-30112, Rev. 1.
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1976. EPISODEB: An Experimental
Package for the Integration of Systems of Ordinary Differential
Equations with Banded Jacobians. LLNL Report UCID-30132, April 1976.
</p>
<p>A. C. Hindmarsh, 1983. ODEPACK, a Systematized Collection of ODE
Solvers. in Scientific Computing, R. S. Stepleman et al., eds.,
North-Holland, Amsterdam, pp. 55-64.
</p>
<p>K. R. Jackson and R. Sacks-Davis, 1980. An Alternative Implementation
of Variable Step-Size Multistep Formulas for Stiff ODEs.  ACM
Trans. Math. Software, 6, pp. 295-318.
doi: <a href="https://doi.org/10.1145/355900.355903">10.1145/355900.355903</a>
</p>
<p>Netlib: <a href="https://www.netlib.org">https://www.netlib.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../deSolve/help/vode.html">vode</a></code> for the double precision version
</p>


<h3>Examples</h3>

<pre>

## =======================================================================
## Example 1 - very simple example 
## df/dt = 1i*f, where 1i is the imaginary unit
## The initial value is f(0) = 1 = 1+0i
## =======================================================================

ZODE &lt;- function(Time, f, Pars) {
  df &lt;-  1i*f
  return(list(df))
}

pars    &lt;- NULL
yini    &lt;- c(f = 1+0i)
times   &lt;- seq(0, 2*pi, length = 100)
out     &lt;- zvode(func = ZODE, y = yini, parms = pars, times = times,
  atol = 1e-10, rtol = 1e-10)

# The analytical solution to this ODE is the exp-function:
# f(t) = exp(1i*t)
#      = cos(t)+1i*sin(t)  (due to Euler's equation)

analytical.solution  &lt;- exp(1i * times) 

## compare numerical and analytical solution
tail(cbind(out[,2], analytical.solution))


## =======================================================================
## Example 2 - example in "zvode.f",  
## df/dt = 1i*f        (same as above ODE)
## dg/dt = -1i*g*g*f   (an additional ODE depending on f)
##
## Initial values are
## g(0) = 1/2.1 and
## z(0) = 1  
## =======================================================================

ZODE2&lt;-function(Time,State,Pars) {
  with(as.list(State), {
    df &lt;- 1i * f
    dg &lt;- -1i * g*g * f
    return(list(c(df, dg)))
  })
}

yini    &lt;- c(f = 1 + 0i, g = 1/2.1 + 0i)
times   &lt;- seq(0, 2*pi, length = 100)
out     &lt;- zvode(func = ZODE2, y = yini, parms = NULL, times = times,
  atol = 1e-10, rtol = 1e-10)


## The analytical solution is
## f(t) = exp(1i*t)   (same as above)
## g(t) = 1/(f(t) + 1.1)

analytical &lt;- cbind(f = exp(1i * times), g = 1/(exp(1i * times) + 1.1))

## compare numerical solution and the two analytical ones:
tail(cbind(out[,2], analytical[,1]))

</pre>

<hr /><div style="text-align: center;">[Package <em>deSolve</em> version 1.30 <a href="00Index.html">Index</a>]</div>
</div></body></html>
