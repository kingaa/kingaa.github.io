<!DOCTYPE html><html><head><title>R: Objective functions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>objfun {pomp}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Objective functions</h2>

<h3>Description</h3>

<p>Methods common to <span class="pkg">pomp</span> stateful objective functions
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="../../pomp/help/Csnippet.html">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="../../pomp/help/pompLoad.html">pompLoad</a></code> or <code><a href="../../pomp/help/pompUnload.html">pompUnload</a></code>:
rather, it is assumed that <code><a href="../../pomp/help/pompLoad.html">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="../../pomp/help/pompLoad.html">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="../../pomp/help/pompLoad.html">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="../../pomp/help/pompLoad.html">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>

<hr /><div style="text-align: center;">[Package <em>pomp</em> version 6.0.4.0 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
