<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Probe matching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for probe matching {pomp}"><tr><td>probe matching {pomp}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Probe matching</h2>

<h3>Description</h3>

<p>Estimation of parameters by maximum synthetic likelihood
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'data.frame'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  params,
  rinit,
  rprocess,
  rmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probed_pomp'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probe_match_objfun'
probe_objfun(
  data,
  est,
  fail.value,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be internally coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr valign="top"><td><code>est</code></td>
<td>
<p>character vector; the names of parameters to be estimated.</p>
</td></tr>
<tr valign="top"><td><code>fail.value</code></td>
<td>
<p>optional numeric scalar;
if non-<code>NA</code>, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).</p>
</td></tr>
<tr valign="top"><td><code>probes</code></td>
<td>
<p>a single probe or a list of one or more probes.
A probe is simply a scalar- or vector-valued function of one argument that can be applied to the data array of a &lsquo;pomp&rsquo;.
A vector-valued probe must always return a vector of the same size.
A number of useful probes are provided with the package:
see <a href="../../pomp/help/basic+20probes.html">basic probes</a>.</p>
</td></tr>
<tr valign="top"><td><code>nsim</code></td>
<td>
<p>the number of model simulations to be computed.</p>
</td></tr>
<tr valign="top"><td><code>seed</code></td>
<td>
<p>integer.
When fitting, it is often best to fix the seed of the random-number generator (RNG).
This is accomplished by setting <code>seed</code> to an integer.
By default, <code>seed = NULL</code>, which does not alter the RNG state.</p>
</td></tr>
<tr valign="top"><td><code>params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr valign="top"><td><code>rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="../../pomp/help/rinit+20specification.html">rinit specification</a>.</p>
</td></tr>
<tr valign="top"><td><code>rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="../../pomp/help/rprocess+20specification.html">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="../../pomp/help/rprocess+20specification.html">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr valign="top"><td><code>rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="../../pomp/help/rmeasure+20specification.html">rmeasure specification</a>.</p>
</td></tr>
<tr valign="top"><td><code>partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="../../pomp/help/parameter_trans.html">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="../../pomp/help/parameter_trans.html">parameter_trans</a></code>.
For more information, see <a href="../../pomp/help/parameter_trans.html">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="../../pomp/help/pomp.html">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="../../pomp/help/pomp.html">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="../../pomp/help/userdata.html">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In probe-matching, one attempts to minimize the discrepancy between simulated and actual data, as measured by a set of summary statistics called <em>probes</em>.
In <span class="pkg">pomp</span>, this discrepancy is measured using the &ldquo;synthetic likelihood&rdquo; as defined by Wood (2010).
</p>


<h3>Value</h3>

<p><code>probe_objfun</code> constructs a stateful objective function for probe matching.
Specifically, <code>probe_objfun</code> returns an object of class &lsquo;probe_match_objfun&rsquo;, which is a function suitable for use in an <code><a href="../../stats/help/optim.html">optim</a></code>-like optimizer.
In particular, this function takes a single numeric-vector argument that is assumed to contain the parameters named in <code>est</code>, in that order.
When called, it will return the negative synthetic log likelihood for the probes specified.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and its estimate of the synthetic likelihood.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="../../pomp/help/pomp.html">cdir</a></code> and <code><a href="../../pomp/help/pomp.html">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p><code><a href="../../stats/help/optim.html">optim</a></code> <code><a href="../../subplex/help/subplex.html">subplex</a></code> <code><a href="../../nloptr/help/nloptr.html">nloptr</a></code>
</p>
<p>More on methods based on summary statistics: 
<code><a href="../../pomp/help/approximate+20Bayesian+20computation.html">approximate Bayesian computation</a></code>,
<code><a href="../../pomp/help/basic+20probes.html">basic probes</a></code>,
<code><a href="../../pomp/help/nonlinear+20forecasting.html">nonlinear forecasting</a></code>,
<code><a href="../../pomp/help/probe.html">probe</a>()</code>,
<code><a href="../../pomp/help/spectrum+20matching.html">spectrum matching</a></code>,
<code><a href="../../pomp/help/spect.html">spect</a>()</code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="../../pomp/help/approximate+20Bayesian+20computation.html">approximate Bayesian computation</a></code>,
<code><a href="../../pomp/help/bsmc2.html">bsmc2</a>()</code>,
<code><a href="../../pomp/help/estimation+20algorithms.html">estimation algorithms</a></code>,
<code><a href="../../pomp/help/mif2.html">mif2</a>()</code>,
<code><a href="../../pomp/help/nonlinear+20forecasting.html">nonlinear forecasting</a></code>,
<code><a href="../../pomp/help/pmcmc.html">pmcmc</a>()</code>,
<code><a href="../../pomp/help/pomp-package.html">pomp-package</a></code>,
<code><a href="../../pomp/help/spectrum+20matching.html">spectrum matching</a></code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="../../pomp/help/mif2.html">mif2</a>()</code>,
<code><a href="../../pomp/help/nonlinear+20forecasting.html">nonlinear forecasting</a></code>,
<code><a href="../../pomp/help/spectrum+20matching.html">spectrum matching</a></code>,
<code><a href="../../pomp/help/trajectory+20matching.html">trajectory matching</a></code>
</p>


<h3>Examples</h3>

<pre>

  gompertz() -&gt; po
  
  ## A list of probes:
  plist &lt;- list(
    mean=probe.mean("Y",trim=0.1,transform=sqrt),
    sd=probe.sd("Y",transform=sqrt),
    probe.marginal("Y",ref=obs(po)),
    probe.acf("Y",lags=c(1,3,5),type="correlation",transform=sqrt),
    probe.quantile("Y",prob=c(0.25,0.75),na.rm=TRUE)
  )

  ## Construct the probe-matching objective function.
  ## Here, we just want to estimate 'K'.
  po %&gt;%
    probe_objfun(probes=plist,nsim=100,seed=5069977,
      est="K") -&gt; f

  ## Any numerical optimizer can be used to minimize 'f'.
  library(subplex)

  subplex(fn=f,par=0.4,control=list(reltol=1e-5)) -&gt; out

  ## Call the objective one last time on the optimal parameters:
  f(out$par)
  coef(f)

  ## There are 'plot' and 'summary' methods:
  f %&gt;% as("probed_pomp") %&gt;% plot()
  f %&gt;% summary()

  ## One can convert an objective function to a data frame:
  f %&gt;% as("data.frame") %&gt;% head()
  f %&gt;% as("probed_pomp") %&gt;% as("data.frame") %&gt;% head()

  f %&gt;% probe() %&gt;% plot()

  ## One can modify the objective function with another call
  ## to 'probe_objfun':

  f %&gt;% probe_objfun(est=c("r","K")) -&gt; f1
  subplex(fn=f1,par=c(0.3,0.3),control=list(reltol=1e-5)) -&gt; out
  f1(out$par)
  coef(f1)

</pre>

<hr /><div style="text-align: center;">[Package <em>pomp</em> version 4.0.8.0 <a href="00Index.html">Index</a>]</div>
</div></body></html>
