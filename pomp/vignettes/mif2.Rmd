---
title: "An IF2 example"
author: "Aaron A. King"
output:
  html_document:
    theme: flatly
    toc: yes
bibliography: pomp.bib
csl: ecology.csl
---

Licensed under the [Creative Commons attribution-noncommercial license](http://creativecommons.org/licenses/by-nc/3.0).
Please share and remix noncommercially, mentioning its origin.  
![CC-BY_NC](../graphics/cc-by-nc.png)

This document was produced using `pomp` version `r packageVersion("pomp")`.

```{r options,include=FALSE,cache=FALSE,purl=FALSE}
library(knitr)
prefix <- "mif2"
opts_chunk$set(
  progress=TRUE,
  prompt=FALSE,tidy=FALSE,highlight=TRUE,
  strip.white=TRUE,
  warning=FALSE,
  message=FALSE,
  error=FALSE,
  echo=TRUE,
  cache=TRUE,
  results='markup',
  fig.show='asis',
  size='small',
  fig.lp="fig:",
  fig.path=paste0("figure/",prefix,"-"),
  cache.path=paste0("cache/",prefix,"-"),
  fig.pos="h!",
  fig.align='center',
  fig.height=4,fig.width=6.83,
  dpi=300,
  dev='png',
  dev.args=list(bg='transparent')
  )
```
```{r prelims,echo=FALSE,cache=FALSE}
require(ggplot2)
require(plyr)
require(reshape2)
require(magrittr)
theme_set(theme_bw())
require(pomp)
stopifnot(packageVersion("pomp")>="0.66-2")
options(
  keep.source=TRUE,
  stringsAsFactors=FALSE,
  encoding="UTF-8",
  scipen=5,
  cores=5
  )
```

Iterated filtering is a technique for maximizing the likelihood obtained by filtering.
In `pomp`, it is the particle filter that is iterated.
The iterated filtering of @Ionides2006 is implemented in the `mif` function.
@Ionides2015 describe an improvement on the original [@Ionides2006] algorithm.
This "IF2" algorithm is implemented in the `mif2` function.

The following constructs the Gompertz example that is provided with `pomp` (see `?gompertz`) and extracts the parameters at which the data were generated.

```{r gompertz-init,cache=FALSE}
require(pomp)
pompExample(gompertz)
theta <- coef(gompertz)
theta.true <- theta
```

Let's use IF2 to obtain an approximate MLE for these data.
We'll initialize the algorithm at several starting points around `theta.true` and just estimate the parameters $r$, $\tau$, and $\sigma$:

```{r gompertz-multi-mif2-eval,results='hide'}
require(foreach)
require(doMC)
registerDoMC()

save.seed <- .Random.seed
set.seed(334388458L,kind="L'Ecuyer")

estpars <- c("r","sigma","tau")
mf <- foreach(i=1:10,
              .inorder=FALSE,
              .options.multicore=list(set.seed=TRUE)
              ) %dopar%
  {
    theta.guess <- theta.true
    theta.guess[estpars] <- rlnorm(
      n=length(estpars),
      meanlog=log(theta.guess[estpars]),
      sdlog=1
      )
    m1 <- mif2(
      gompertz,
      Nmif=50,
      start=theta.guess,
      transform=TRUE,
      rw.sd=rw.sd(r=0.02,sigma=0.02,tau=0.05),
      cooling.fraction.50=0.95,
      Np=2000
      )
    m1 <- continue(m1,Nmif=50,cooling.fraction=0.8)
    m1 <- continue(m1,Nmif=50,cooling.fraction=0.6)
    m1 <- continue(m1,Nmif=50,cooling.fraction=0.2)
    ll <- replicate(n=10,logLik(pfilter(m1,Np=10000)))
    list(mif=m1,ll=ll)
    }
```

Note that we've set `transform=TRUE` in the above to search for the MLE with the parameters transformed to enforce their positivity.
See the `pomp` documentation (`?pomp`) and the section on Parameter Transformations in the [Getting Started vignette](http://pomp.r-forge.r-project.org/vignettes/getting_started.html)).

Each of the `r length(mf)` `mif2` runs ends up at a different point estimate.
We focus on that with the highest estimated likelihood, having evaluated the likelihood several times to reduce the Monte Carlo error in the likelihood evaluation.
The particle filter produces an unbiased estimate of the likelihood; 
therefore, we will average the likelihoods, not the log likelihoods.

```{r gompertz-post-mif2}
loglik.true <- replicate(n=10,logLik(pfilter(gompertz,Np=10000)))
loglik.true <- logmeanexp(loglik.true,se=TRUE)
theta.mif <- t(sapply(mf,function(x)coef(x$mif)))
loglik.mif <- t(sapply(mf,function(x)logmeanexp(x$ll,se=TRUE)))
best <- which.max(loglik.mif[,1])
theta.mif <- theta.mif[best,]
loglik.mif <- loglik.mif[best,]
rbind(
  mle=c(signif(theta.mif[estpars],3),loglik=round(loglik.mif,2)),
  truth=c(signif(theta.true[estpars],3),loglik=round(loglik.true,2))
  ) -> results.table
```

Convergence plots can be used to help diagnose convergence of the iterated filtering algorithm.
Something like the following can be obtained by executing `plot(mf)`.

```{r mif2-plot,echo=FALSE,cache=FALSE,fig.height=6}
op <- par(mfrow=c(4,1),mar=c(3,3,0,0),mgp=c(2,1,0),bty='l')
loglik <- sapply(mf,function(x)conv.rec(x$mif,"loglik"))
log.r <- sapply(mf,function(x)conv.rec(x$mif,"r"))
log.sigma <- sapply(mf,function(x)conv.rec(x$mif,"sigma"))
log.tau <- sapply(mf,function(x)conv.rec(x$mif,"tau"))
matplot(loglik,type='l',lty=1,xlab="",ylab=expression(log~L),xaxt='n',ylim=max(loglik,na.rm=T)+c(-12,3))
matplot(log.r,type='l',lty=1,xlab="",ylab=expression(log~r),xaxt='n')
matplot(log.sigma,type='l',lty=1,xlab="",ylab=expression(log~sigma),xaxt='n')
matplot(log.tau,type='l',lty=1,xlab="MIF iteration",ylab=expression(log~tau))
par(op)
```

Here is a summary of the results.
```{r first-mif-results-table,echo=FALSE,cache=FALSE}
print(results.table)
```
The fact that the likelihood at the putative MLE is higher than it is at the truth is evidence that this parameter is actually close to the true MLE.

## References
